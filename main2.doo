module main2

import std/maybe
import std/table
import std/map
import std/sparse

type Person {string, i32}

type[T] TreeNode   ( NodeBranch:(i64, i64) | NodeLeaf:null)
type[T] TreeRecord { node:TreeNode(T), elem:T} 
type[T] Tree (
    base : Maybe(  Key(TreeRecord(T)) )
    nodes: Sparse( TreeRecord(T) )
)


fn[T] {tree:Tree(T)} insert(elem:()T)
    data record ()TreeRecord(T)
    record.node   = NodeLeaf()
    record.elem{} = elem{}
    let elemKey = tree.nodes.insert(record)
    //switch tree.nodes.at(elemKey)
    //    {NodeLeaf(), x}; print("here", x)

    switch tree.base
        Nothing(); tree.base = Just(elemKey)
        Just(baseKey)
            let key = baseKey
            while tree.nodes.get(key).node -> NodeBranch((left, right))
                if elem{} < tree.nodes.get(key).elem{}
                    key = conv(left)
                else; key = conv(right)

            data newLeaf ()TreeRecord(T)
            newLeaf.elem{} = tree.nodes.get(key).elem{}
            newLeaf.node   = NodeLeaf()
            let newLeafKey = tree.nodes.insert( newLeaf )

            data newBranch ()TreeRecord(T)
            newBranch.elem{} = elem{}
            if elem{} < tree.nodes.get(key).elem{}
                newBranch.elem{} = tree.nodes.get(key).elem{}
                newBranch.node   = NodeBranch((conv(elemKey), conv(newLeafKey)))
            else
                newBranch.elem{} = elem{}
                newBranch.node   = NodeBranch((conv(newLeafKey), conv(elemKey)))

            tree.nodes.replace(key, newBranch)

fn[T] {tree:Tree(T)} printTree()
    fn[T] {tree:Tree(T)} printNode(key:Key(TreeRecord(T)))
        switch tree.nodes.get(key).node
            NodeLeaf(); print(tree.nodes.get(key).elem)
            NodeBranch((left, right))
                tree.printNode(conv(left))
                tree.printNode(conv(right))
                    
    switch tree.base
        Nothing(); print("empty")
        Just(key); tree.printNode(key)
                
    
fn testTree()
    data tree Tree(i64)
    tree.insert(10)
    tree.insert(19)
    tree.insert(3)
    tree.insert(433)
    tree.insert(2)
    //tree.printTree()

    data tree2 Tree(string)
    tree2.insert("benzhis")
    tree2.insert("benis")
    tree2.insert("beni")
    tree2.insert("bongis")
    tree2.insert("banghis")
    tree2.insert("benghis")
    //tree2.printTree()

    data tree3 Tree(Person)
    tree3.insert( ("jorinz", 35) )
    tree3.insert( ("joranz", 39) )
    tree3.insert( ("jaranz", 50) )
    tree3.insert( ("jaranz", 36) )
    //tree3.printTree()

    data tree4 Tree((){bool, Person})
    tree4.insert( (true, "jorinz", 35) )
    tree4.insert( (true, "joranz", 39) )
    tree4.insert( (true, "jaranz", 50) )
    tree4.insert( (true, "jaranz", 36) )
    tree4.printTree()

    print("testTree passed")


fn testTuple()
    let t1 = (1, true, "three"):(){i64, bool, string}
    let t2 = (2, false, "four"):(){i64, {bool, string}}

    type Person {name:string, age:i64}
    type MyType {person:Person, something:bool}
    type Index i64

    let t3 = ("jim", 50):()Person
    let 50    = t3.age
    let "jim" = t3.name

    let t4 = ("james", 32, 3):(){Person, Index}
    let "james" = t4.Person.name
    let {"james", 32} = t4.Person
    let 3             = t4.Index

    type BigType {Index, Person, bool, MyType}
    let t5 = (1, "two", 3, false, "five", 6, true):()BigType
    let "five" = t5.MyType.Person.name
    let "five" = t5.MyType.person.name
    let 3      = t5.Person.age

    print("testTuple passed")


fn testTable()
    data tab1 []i64
    tab1.push(3)
    let {3} = tab1.at(0)
    let 1 = tab1.length()
    let 3 = tab1.pop()
    let 0 = tab1.length()

    data tab2 []()()i64
    tab2.push(65)
    let 65 = tab2.pop()

    data tab3 []{i64, bool}
    tab3.push( (1, true) )
    let {1, true} = tab3[0]

    data tab4 []Key(i64)
    tab4.push(3)
    let 3 = tab4.pop()

    type[T] AnotherRecord {bool, T}
    data tab5 []AnotherRecord(Person)
    tab5.push( (true, "jorinz", 49) )
    let (true, "jorinz", 49) = tab5.pop()

    print("testTable passed")


fn testMap()
    data map1 Map(i64, string)

    map1.insert(3, "three")
    map1.insert(4, "four")
    map1.insert(5, "six")
    map1.insert(5, "five")

    let Just("five") = map1.find(5)
    let Just("three") = map1.find(3)
    let Nothing()     = map1.find(2)

    data map2 Map( {i64, string}, i8 )

    map2.insert( (1, "two"), 3 )
    map2.insert( (1, "tw0"), 2 )
    map2.insert( (1, "two"), 4 )

    let Just(4) = map2.find( (1, "two") )
    let Just(2) = map2.find( (1, "tw0") )
    let Nothing() = map2.find( (1, "Two") )

    data map3 Map ( (i64, string), i8 )

    map3.insert( (1, "two"), 3 )

    print("testMap passed")


fn testPatRecord()
    let x = 3
    if x{} -> {y}
        y = 4
    //let 4 = x

    //let x2 = (3, 4)
    //if x2{} -> {a, b}
    //    b = 5
    //    a = 2
    //let (2, 5) = x2

    print("testPatRecord passed")


fn testSparse()
    data s1 Sparse(i64)
    let 0 = s1.insert(3)
    let 1 = s1.insert(4)
    let 2 = s1.insert(5)
    s1.delete(1)
    let 1 = s1.insert(6)
    let 3 = s1.insert(7)
    let 7 = s1.get(3)

    data s2 Sparse(Person)
    let key = s2.insert( ("jones", 44) )
    let ("jones", 44) = s2.get(key)


    print("testSparse passed")


fn main()
    testTuple()
    testTable()
    testMap()
    testSparse()
    testTree()
    testPatRecord()
    print("main2 finished")
