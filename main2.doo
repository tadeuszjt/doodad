module main2

type Person {string, i32}

fn[T] {t:[]T} length() i64
    ${ return $t->len; }

fn[T] {t:[]T} push(elem:()T)
    t++
    t[t.length() - 1] = elem{}

fn[T] {t:[]T} pop()
    ${ $t->len--; }


type[K, V] Map (keys:[]K, values:[]V)

fn[K, V] {m:Map(K, V)} insert(key:()K, value:()V)
    m.keys.push(key)
    m.values.push(value)
    return


fn[K, V] {m:Map(K, V)} find(key:()K) Maybe(()V)
    for m.keys[..] -> i
        if m.keys[i] == key{}
            return Just( conv(m.values[i]):()V )
    return Nothing()

type[T] Maybe (Nothing:null | Just:T)
type[T] Sparse (values:[]T, empty:[]i64)

fn[T] {s:Sparse(T)} insert(value:()T) i64
    if s.empty.length() > 0
        let key = 0
        key{} = s.empty[s.empty.length() - 1]
        s.empty.pop()
        s.values[key] = value{}
        return key

    s.values.push(value)
    return s.values.length() - 1


fn[T] {s:Sparse(T)} delete(key:i64)
    if key == s.values.length() - 1
        s.values.pop()
    else
        s.empty.push(key)


fn main()
    let t = ("benis", 12):()Person

    data tab []Person
    tab.push(t)

    data map Map(string, bool)
    data map2 Map({string, bool}, i64)
    data map3 Map((string, bool), string)

    map.insert("benis", true)
    map2.insert( ("bongis", false), 1 )
    //map3.insert( ("bongis", true),  "value" )

    for tab -> x
        print(x)

    for map2.keys -> x
        print(x)

    let z = map.find("benis")
    switch z
        Nothing(); print("nothing")
        Just(x);   print("Just", x) 


    let Just(x) = map2.find( ("bongis", false) )
    //let Just(y) = map3.find( ("bongis", true) )
    print(x)


    data sparse Sparse(string)
    let key1 = sparse.insert("benis")
    let key2 = sparse.insert("bongis")

    for sparse.values -> v
        print(v)
    print(key1, key2)


    print("main2 finished")




