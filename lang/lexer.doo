module lexer 

import ../std/io
import ../std/strings
import ../std/chars

type Idx i64


type Lexeme { 
    LexChar(char)
    LexIdent(Idx)
    LexInt(i64)
    LexKeyword(Idx)
    LexType(Idx)
    LexSym(char)
    LexDoubleSym(char, char) 
    LexNewline(Idx)
    LexCharLit(char)
    LexStringLit(Idx)
}


type LexResult { LexSuccess(Lexeme, Idx) | null }
type Result { null | Success(Lexeme, Idx) }
type Stack string


fn {s Stack} at(idx Idx) {null | char}
    if s[..][idx] && s[idx] != '\0'
        return conv(s[idx])
    return null


fn {s Stack, str string} read(idx Idx)
    while s.at(idx) -> char(c)
        str.push(c)
        idx = idx + 1


fn {s Stack} popString() 
    while s.at(s.len() - 1) -> char(c)
        s.pop()


fn {s Stack} lexChar(idx Idx, x char) Result
    if s.at(idx) -> char(c) | c == x
        return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} lexAlpha(idx Idx) Result
    if s.at(idx) -> char(c) | isAlpha(c)
        return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} lexSpace(idx Idx) Result
    if s.at(idx) -> char(c) | c == ' ' || c == '\t'
        return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} lexDigit(idx Idx) Result
    if s.at(idx) -> char(c) | isDigit(c)
        return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} skipSpaces(idx Idx) Idx
    while s.lexSpace(idx) -> Success(_, end)
        idx = end
    return idx


fn {s Stack} lexInt(idx Idx) Result 
    let count = 0
    let n = 0
    while s.at(idx + count) -> char(c) | isDigit(c)
        n = n * 10
        n = n + i64(c - '0')
        count = count + 1

    if count > 0; return Success(LexInt(n), idx + count)
    else;         return null


fn {s Stack} lexIdent(idx Idx) Result
    if s.lexAlpha(idx) -> null; return null
    s.push('\0')
    let id = s.len()

    while true
        if s.lexAlpha(idx) -> Success(LexChar(c), end) 
            s.push(c)
            idx = end
        else if s.lexDigit(idx) -> Success(LexChar(c), end)
            s.push(c)
            idx = end
        else; return Success(LexIdent(id), idx)


fn {s Stack} lexType(idx Idx) Result
    if s.lexIdent(idx) -> Success(LexIdent(id), end) 
        data ident string 
        {s, ident}.read(id) 

        let match = true 
        switch ident 
            "i8";
            "i16";
            "i32";
            "i64";
            "f32";
            "f64";
            "bool";
            "char";
            "unsafe_ptr";
            "string";
            "sparse";
            "map";
            _; match = false

        if match; return Success(LexType(id), end)
        else; s.popString()

    return null


fn {s Stack} lexKeyword(idx Idx) Result
    if s.lexIdent(idx) -> Success(LexIdent(id), end)
        data ident string 
        {s, ident}.read(id)

        let match = true
        switch ident 
            "for";
            "let";
            "fn";
            "null";
            "conv";
            "import";
            "module";
            "type";
            "true";
            "false";
            "return";
            "if";
            "else";
            _; match = false

        if match; return Success(LexKeyword(id), end)
        else    ; s.popString()

    return null


fn {s Stack} lexGraphic(idx Idx) Result
    data syms string "-/<>[]{}().,;:|=!@#$%^&*()_+ "
    if s.at(idx) -> char(c)
        for syms -> sym 
            if sym == c; return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} lexSym(idx Idx) Result
    data syms string "+-*/%<>[]{}().,;:|=_"
    if s.at(idx) -> char(c)
        for syms -> sym 
            if sym == c; return Success(LexSym(c), idx + 1)
    return null

fn {s Stack} lexDoubleSym(idx Idx) Result
    data chars2 [2 char]
    if s.at(idx)     -> char(c); chars2[0] = c
    if s.at(idx + 1) -> char(c); chars2[1] = c
    switch chars2
        "==";
        "!=";
        ">=";
        "<=";
        "||";
        "&&";
        "..";
        "->";
        "::";
        _; return null
    return Success(LexDoubleSym(chars2[0], chars2[1]), idx + 2)


fn {s Stack} lexEscaped(idx Idx) Result 
    data chars2 [2 char] 
    if s.at(idx)     -> char(c); chars2[0] = c
    if s.at(idx + 1) -> char(c); chars2[1] = c

    switch chars2
        ['\\', 'n']; return Success(LexChar('\n'), idx + 2)
        ['\\', 't']; return Success(LexChar('\t'), idx + 2)
        ['\\', '0']; return Success(LexChar('\0'), idx + 2)
        ['\\', '\'']; return Success(LexChar('\''), idx + 2)
        ['\\', '\\']; return Success(LexChar('\\'), idx + 2)
        _; return null


fn {s Stack} lexCharLit(idx Idx) Result
    if s.at(idx) -> char('\'')
        idx = idx + 1
        let result = null
        if s.lexEscaped(idx)      -> Success(x, y); result = Success(x, y)
        else if s.lexAlpha(idx)   -> Success(x, y); result = Success(x, y)
        else if s.lexDigit(idx)   -> Success(x, y); result = Success(x, y)
        else if s.lexGraphic(idx) -> Success(x, y); result = Success(x, y)
        else if s.at(idx) -> char('"'); result = Success(LexChar('"'), idx + 1)

        if result -> Success(LexChar(c), end)
            idx = end
            if s.at(idx) -> char('\'')
                return Success(LexCharLit(c), idx + 1)

    return null


fn {s Stack} lexStringLitChar(idx Idx) Result
    if s.lexEscaped(idx) -> Success(a, b); return Success(a, b)
    if s.lexAlpha(idx)   -> Success(a, b); return Success(a, b)
    if s.lexDigit(idx)   -> Success(a, b); return Success(a, b)
    if s.lexSpace(idx)   -> Success(a, b); return Success(a, b)
    if s.lexGraphic(idx) -> Success(a, b); return Success(a, b)
    return null


fn {s Stack} lexStringLit(idx Idx) Result 
    if s.at(idx) -> char('"')
        idx = idx + 1

        data chars string
        while s.lexStringLitChar(idx) -> Success(LexChar(c), end)
            chars.push(c)
            idx = end

        if s.at(idx) -> char('"')
            idx = idx + 1
            s.push('\0')
            let id = s.len()
            for chars -> c; s.push(c)
            return Success(LexStringLit(id), idx)

    return null


fn {s Stack} lexNewline(idx Idx) Result
    if s.at(idx) -> char('\n')
        while s.at(idx) -> char('\n')
            idx = idx + 1
        
        s.push('\0')
        let id = s.len()
        
        while s.at(idx) -> char(c) | c == ' ' || c == '\t'
            s.push(c)
            idx = idx + 1

        return Success(LexNewline(id), idx)
    return null


fn {s Stack} lex(idx Idx) Result
    idx = s.skipSpaces(idx)
    if s.lexNewline(idx)   -> Success(l, end); return Success(l, end)
    if s.lexStringLit(idx) -> Success(l, end); return Success(l, end)
    if s.lexType(idx)      -> Success(l, end); return Success(l, end)
    if s.lexKeyword(idx)   -> Success(l, end); return Success(l, end)
    if s.lexIdent(idx)     -> Success(l, end); return Success(l, end)
    if s.lexInt(idx)       -> Success(l, end); return Success(l, end)
    if s.lexDoubleSym(idx) -> Success(l, end); return Success(l, end)
    if s.lexSym(idx)       -> Success(l, end); return Success(l, end)
    if s.lexCharLit(idx)   -> Success(l, end); return Success(l, end)
    return null


fn {io Io, s Stack} writeLexeme(lexeme Lexeme)
    switch lexeme 
        LexChar(c)
            {io, "chr: "}.write()
            io.write(c)
        LexSym(c)
            {io, "sym: "}.write()
            io.write(c)
        LexInt(n)
            {io, "int: "}.write()
            io.write(n)
        LexDoubleSym(a, b)
            {io, "sym: "}.write()
            io.write(a)
            io.write(b)
        LexIdent(id)
            {io, "idt: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexKeyword(id)
            {io, "kwd: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexType(id)
            {io, "typ: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexNewline(id)
            {io, "nln: "}.write()
            while s.at(id) -> char(c)
                switch c
                    '\n'; io.write('n')
                    '\t'; io.write('t')
                    ' '; io.write('s')
                id = id + 1
        LexCharLit(c)
            {io, "lit: "}.write()
            switch c
                ' '; io.write('s')
                '\t'; io.write('t')
                '\n'; io.write('n')
                '\0'; io.write('0')
                _; io.write(c)
        LexStringLit(id)
            {io, "str: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        _; print("<unknown lexeme>")



fn {io Io} main() 
    let file = {io, "lang/lexer.doo"}.openFile()

    data stack Stack 
    while io.read(file) -> char(c)
        stack.push(c)

    data indentStack [string]
    indentStack.push()

    let idx = 0
    while stack.lex(idx) -> Success(lexeme, end)
        if lexeme -> LexNewline(id)
            data indent string 
            {stack, indent}.read(id)

            if indent == indentStack[indentStack.len() - 1]
                io.write(i64(idx))
                io.write(' ')
                {io, "ind: N"}.writeLn()
            else if {indent, indentStack[indentStack.len() - 1]}.isPrefix()
                io.write(i64(idx))
                io.write(' ')
                {io, "ind: I"}.writeLn()
                indentStack[indentStack.push()] = indent

            else 
                while indent != indentStack[indentStack.len() - 1]
                    io.write(i64(idx))
                    io.write(' ')
                    {io, "ind: D"}.writeLn()
                    if indentStack.len() == 0
                        {io, "INDENT ERRROR"}.writeLn()
                        return
                    else; indentStack.pop()

        else
            io.write(i64(idx))
            io.write(' ')
            {io, stack}.writeLexeme(lexeme)
            io.write('\n')

        idx = end





