module lexer 

import ../std/io
import ../std/strings
import ../std/chars

type Idx i64


type Lexeme { 
    LexChar(char)
    LexIdent(Idx)
    LexInt(i64)
    LexFloat(Idx)
    LexKeyword(Idx)
    LexType(Idx)
    LexSym(char)
    LexDoubleSym(char, char) 
    LexNewline(Idx)
    LexCharLit(char)
    LexStringLit(Idx)
    LexImport(Idx)
    LexImportC(Idx)
}


type Result { null | Success(Lexeme, Idx) }
type Stack string


fn {s Stack} at(idx Idx) {null | char}
    if s[..][idx] && s[idx] != '\0'
        return conv(s[idx])
    return null


fn {s Stack, str string} read(idx Idx)
    while s.at(idx) -> char(c)
        str.push(c)
        idx = idx + 1


fn {s Stack} popString() 
    while s.at(s.len() - 1) -> char(c)
        s.pop()


fn {s Stack} lexFloat(idx Idx) Result
    data chars string 
    while s.at(idx) -> char(c) | isDigit(c) 
        idx = idx + 1
        chars.push(c)
    if chars == ""; return null

    if s.at(idx) -> char('.')
        idx = idx + 1
        chars.push('.')
    else; return null

    let hasDigits = false
    while s.at(idx) -> char(c) | isDigit(c) 
        idx = idx + 1
        chars.push(c)
        hasDigits = true
    if !hasDigits; return null

    let id = s.push('\0') + 1
    for chars -> c; s.push(c)
    return Success(LexFloat(id), idx)
            


fn {s Stack} lexInt(idx Idx) Result 
    let count = 0
    let n = 0
    while s.at(idx + count) -> char(c) | isDigit(c)
        n = n*10 + i64(c - '0')
        count = count + 1

    if count > 0; return Success(LexInt(n), idx + count)
    else;         return null


fn {s Stack} lexIdent(idx Idx) Result
    if s.at(idx) -> char(c) | isAlpha(c)
        let id = s.push('\0') + 1

        while s.at(idx) -> char(c) | isAlpha(c) || isDigit(c) || c == '_'
            idx = idx + 1
            s.push(c)
        return Success(LexIdent(id), idx)
    return null


fn {s Stack} lexImport(idx Idx) Result
    if s.lexIdent(idx) -> null; return null
    let Success(LexIdent(id), end) = s.lexIdent(idx)
    idx = end

    data importStr string
    {s, importStr}.read(id)
    s.popString()

    switch importStr
        "import";
        "import_c";
        _; return null

    let retId = s.push('\0') + 1

    while s.at(idx) -> char(c) | c == ' ' || c == '\t'
        idx = idx + 1

    while s.at(idx) -> char(c) | c != '\n' && c != ';'
        s.push(c)
        idx = idx + 1

    switch importStr
        "import";   return Success(LexImport(retId), idx)
        "import_c"; return Success(LexImportC(retId), idx)


fn {s Stack} lexType(idx Idx) Result
    if s.lexIdent(idx) -> Success(LexIdent(id), end) 
        data ident string 
        {s, ident}.read(id) 

        let match = true 
        switch ident 
            "i8";
            "i16";
            "i32";
            "i64";
            "f32";
            "f64";
            "bool";
            "char";
            "string";
            "sparse";
            "map";
            _; match = false

        if match; return Success(LexType(id), end)
        else; s.popString()

    return null


fn {s Stack} lexKeyword(idx Idx) Result
    if s.lexIdent(idx) -> Success(LexIdent(id), end)
        data ident string 
        {s, ident}.read(id)

        let match = true
        switch ident 
            "fn";
            "type";
            "if";
            "else";
            "let";
            "while";
            "return";
            "switch";
            "true";
            "false";
            "module";
            "for";
            "null";
            "data";
            _; match = false

        if match; return Success(LexKeyword(id), end)
        else    ; s.popString()

    return null


fn {s Stack} lexGraphic(idx Idx) Result
    data syms string "-/<>[]{}().,;:|=!?@#$%^&*()_+ "
    if s.at(idx) -> char(c)
        for syms -> sym 
            if sym == c; return Success(LexChar(c), idx + 1)
    return null


fn {s Stack} lexSym(idx Idx) Result
    data syms string "+-*/%<>[]{}().,;:|=_!"
    if s.at(idx) -> char(c)
        for syms -> sym 
            if sym == c; return Success(LexSym(c), idx + 1)
    return null


fn {s Stack} lexDoubleSym(idx Idx) Result
    data chars2 [2 char]
    if s.at(idx)     -> char(c); chars2[0] = c
    if s.at(idx + 1) -> char(c); chars2[1] = c
    switch chars2
        "==";
        "!=";
        ">=";
        "<=";
        "||";
        "&&";
        "..";
        "->";
        "::";
        _; return null
    return Success(LexDoubleSym(chars2[0], chars2[1]), idx + 2)


fn {s Stack} lexEscaped(idx Idx) Result 
    switch (s.at(idx), s.at(idx + 1))
        (char('\\'), char('n'));  return Success(LexChar('\n'), idx + 2)
        (char('\\'), char('t'));  return Success(LexChar('\t'), idx + 2)
        (char('\\'), char('0'));  return Success(LexChar('\0'), idx + 2)
        (char('\\'), char('\\')); return Success(LexChar('\\'), idx + 2)
        _; return null


fn {s Stack} lexCharLit(idx Idx) Result
    if s.at(idx) -> char('\'')
        idx = idx + 1
        let result = null
        if s.lexEscaped(idx)             -> Success(x, y); result = Success(x, y)
        else if (s.at(idx), s.at(idx+1)) -> (char('\\'), char('\''))
            result = Success(LexChar('\''), idx + 2)
        else if s.at(idx)                -> char(c) | isAlpha(c) || isDigit(c) || c == '"'
            result = Success(LexChar(c), idx + 1)
        else if s.lexGraphic(idx)        -> Success(x, y); result = Success(x, y)

        if result -> Success(LexChar(c), end)
            idx = end
            if s.at(idx) -> char('\'')
                return Success(LexCharLit(c), idx + 1)

    return null


fn {s Stack} lexStringLitChar(idx Idx) Result
    if (s.at(idx), s.at(idx+1)) -> (char('\\'), char('"'))
        return Success(LexChar('"'), idx + 2)
    if s.lexEscaped(idx) -> Success(a, b); return Success(a, b)

    if s.at(idx) -> char(c) | isAlpha(c) || isDigit(c) || c == '\'' || c == ' ' || c == '\t'
        return Success(LexChar(c), idx + 1)
    if s.lexGraphic(idx) -> Success(a, b); return Success(a, b)
    return null


fn {s Stack} lexStringLit(idx Idx) Result 
    if s.at(idx) -> char('"')
        idx = idx + 1

        let id = s.push('\0') + 1

        while s.lexStringLitChar(idx) -> Success(LexChar(c), end)
            switch c 
                '\n'
                    s.push('\\')
                    s.push('n')
                '\t'
                    s.push('\\')
                    s.push('t')
                '\0'
                    s.push('\\')
                    s.push('0')
                '"'
                    s.push('\\')
                    s.push('"')
                '\\'
                    s.push('\\')
                    s.push('\\')
                _
                    s.push(c)
            idx = end

        if s.at(idx) -> char('"')
            return Success(LexStringLit(id), idx + 1)
        else; s.popString()

    return null


fn {s Stack} lexNewline(idx Idx) Result
    data chars string 
    while s.at(idx) -> char(c) | c == ' ' || c == '\t' || c == '\n'
        idx = idx + 1
        chars.push(c)

    let lastNPos = -1
    for chars[..] -> i | chars.len() - i - 1 -> j | lastNPos == -1
        if chars[j] == '\n'; lastNPos = j
    if lastNPos == -1; return null

    let id = s.push('\0') + 1
    for chars[lastNPos + 1..] -> i; s.push(chars[i])
    return Success(LexNewline(id), idx)


fn {s Stack} lex(idx Idx) Result
    while s.at(idx) -> char(c) | c == ' ' || c == '\t'; idx = idx + 1
    if s.lexNewline(idx)   -> Success(l, end); return Success(l, end)
    if s.lexStringLit(idx) -> Success(l, end); return Success(l, end)
    if s.lexType(idx)      -> Success(l, end); return Success(l, end)
    if s.lexImport(idx)    -> Success(l, end); return Success(l, end)
    if s.lexKeyword(idx)   -> Success(l, end); return Success(l, end)
    if s.lexIdent(idx)     -> Success(l, end); return Success(l, end)
    if s.lexFloat(idx)     -> Success(l, end); return Success(l, end)
    if s.lexInt(idx)       -> Success(l, end); return Success(l, end)
    if s.lexDoubleSym(idx) -> Success(l, end); return Success(l, end)
    if s.lexSym(idx)       -> Success(l, end); return Success(l, end)
    if s.lexCharLit(idx)   -> Success(l, end); return Success(l, end)
    return null


fn {io Io, s Stack} writeLexeme(lexeme Lexeme)
    switch lexeme 
        LexChar(c)
            {io, "chr: "}.write()
            io.write(c)
        LexSym(c)
            {io, "sym: "}.write()
            io.write(c)
        LexInt(n)
            {io, "int: "}.write()
            io.write(n)
        LexFloat(id)
            {io, "flt: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexDoubleSym(a, b)
            {io, "sym: "}.write()
            io.write(a)
            io.write(b)
        LexImport(id)
            {io, "imp: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexImportC(id)
            {io, "imc: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexIdent(id)
            {io, "idt: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexKeyword(id)
            {io, "kwd: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexType(id)
            {io, "typ: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        LexNewline(id)
            {io, "nln: "}.write()
            while s.at(id) -> char(c)
                switch c
                    '\n'; io.write('n')
                    '\t'; io.write('t')
                    ' '; io.write('s')
                id = id + 1
        LexCharLit(c)
            {io, "chr: "}.write()
            io.write('\'')
            switch c
                '\t'
                    io.write('\\')
                    io.write('t')
                '\n'
                    io.write('\\')
                    io.write('n')
                '\0'
                    io.write('\\')
                    io.write('0')
                '\''
                    io.write('\\')
                    io.write('\'')
                '\\'
                    io.write('\\')
                    io.write('\\')
                _; io.write(c)
            io.write('\'')
        LexStringLit(id)
            {io, "str: "}.write()
            while s.at(id) -> char(c)
                io.write(c)
                id = id + 1
        _; print("<unknown lexeme>")



fn {io Io} writeTextPos(idx Idx, line i64, column i64)
    io.write(i64(idx))
    io.write(':')
    io.write(line)
    io.write(':')
    io.write(column)


fn {io Io} main() 
    data stack Stack 
    while io.read() -> char(c)
        stack.push(c)

    data indentStack [string]
    indentStack.push()

    let idx = 0
    let line = 1
    let column = 0
    while stack.lex(idx) -> Success(lexeme, end)
        for [idx .. end] -> i
            let char(c) = stack.at(i)
            if c == '\n'
                line = line + 1
                column = 0
            else
                column = column + 1

        io.writeTextPos(idx, line, column)
        if lexeme -> LexNewline(id)
            data indent string 
            {stack, indent}.read(id)

            if indent == indentStack[indentStack.len() - 1]
                {io, "\tind: N"}.writeLn()
            else if {indent, indentStack[indentStack.len() - 1]}.isPrefix()
                {io, "\tind: I"}.writeLn()
                indentStack[indentStack.push()] = indent
            else 
                {io, "\tind: N"}.writeLn()
                while indent != indentStack[indentStack.len() - 1]
                    if indentStack.len() == 1
                        {io, "\tINDENT ERRROR"}.writeLn()
                        return

                    indentStack.pop()
                    io.writeTextPos(idx, line, column)
                    {io, "\tind: D"}.writeLn()

        else
            io.write('\t')
            {io, stack}.writeLexeme(lexeme)
            io.write('\n')

        idx = end

    if stack.at(idx) -> char(c) 
        print("lex error at ", column)



