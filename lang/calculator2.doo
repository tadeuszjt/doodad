module calculator2

import ../std/chars
import ../std/io

type Item {
    EOF()
    Epsilon()
    E()
    E_()
    T()
    T_()
    F()
    TokInt(i64)
    TokSym(char)
}

type LexResult { null | LexSuccess(Item, i64) }


fn printItem(item Item)
    switch item
        EOF(); print("EOF")
        Epsilon(); print("Epsilon")
        E(); print("E")
        E_(); print("E_")
        T(); print("T")
        T_(); print("T_")
        F(); print("F")
        TokInt(n); print("TokInt", n)
        TokSym(c); print("TokSym", c)


fn {s string} at(idx i64) { null | char }
    if s[..][idx]
        return conv(s[idx])
    return null

fn {ts [Item]} at(idx i64) Item 
    if ts[..][idx]
        return ts[idx]
    return EOF()

fn {s string} lexInt(idx i64) LexResult
    if s.at(idx) -> char(c) | isDigit(c)
        let n = 0
        while s.at(idx) -> char(c) | isDigit(c)
            n = n*10 + i64(c - '0')
            idx = idx + 1

        return LexSuccess(TokInt(n), idx)
    return null

fn {s string} lexSym(idx i64) LexResult
    if s.at(idx) -> char(c) | c == '+' || c == '*' || c == '(' || c == ')'
        return LexSuccess(TokSym(c), idx + 1)
    return null

fn {s string} lex(idx i64) LexResult
    while s.at(idx) -> char(c) | isSpace(c); idx = idx + 1
    if s.lexInt(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    if s.lexSym(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    return null

fn {s string, tokens [Item]} lexString() bool
    let idx = 0
    while s.lex(idx) -> LexSuccess(token, end)
        idx = end
        tokens.push(token)
    return idx == s.len()


fn {s [Item]} pushDerivation(item Item, lookAhead Item) bool
    switch (item, lookAhead)
        (EOF(), EOF());
        (E(), TokSym('('))
            s.push(E_())
            s.push(T())
        (E(), TokInt(n))
            s.push(E_())
            s.push(T())
        (E_(), TokSym('+'))
            s.push(E_())
            s.push(T())
            s.push(TokSym('+'))
        (E_(), TokSym(')'))
            s.push(Epsilon())
        (E_(), EOF())
            s.push(Epsilon())
        (T(), TokSym('('))
            s.push(T_())
            s.push(F())
        (T(), TokInt(n))
            s.push(T_())
            s.push(F())
        (T_(), TokSym('+'))
            s.push(Epsilon())
        (T_(), TokSym('*'))
            s.push(T_())
            s.push(F())
            s.push(TokSym('*'))
        (T_(), TokSym(')'))
            s.push(Epsilon())
        (T_(), EOF())
            s.push(Epsilon())
        (F(), TokSym('('))
            s.push(TokSym(')'))
            s.push(E())
            s.push(TokSym('('))
        (F(), TokInt(n))
            s.push(TokInt(n))
        _
            print("pushDerivation failed")
            return false
    return true


fn isNonTerminal(item Item) bool 
    switch item
        E(); return true
        E_(); return true
        T(); return true
        T_(); return true
        F(); return true
        _; return false


fn isTerminal(item Item) bool
    switch item
        TokSym(_); return true
        TokInt(_); return true
        _; return false


type Result { Success() | Fail() | Finished() }
fn {tokens [Item]} parseTokens() Result
    data stack [Item]
    stack.push(EOF())
    stack.push(E())
    let tokenCursor = 0

    while stack.len() > 0
        let item = stack.pop()
        print("popped item: ")
        printItem(item)

        if item == EOF()
            print("EOF on stack: finished")
            return Finished()

        else if item == Epsilon()
            print("epsilon, do nothing.")

        else if isNonTerminal(item)
            let lookahead = tokens.at(tokenCursor)
            print("lookahead: ")
            printItem(lookahead)
            let success = stack.pushDerivation(item, lookahead)

            print("pushed derivation. new stack: ")
            for stack -> item; printItem(item)
            if !success
                return Fail()

        else if isTerminal(item)
            if tokens[tokenCursor] == item
                print("matched terminal:")
                printItem(item)
                tokenCursor = tokenCursor + 1
            else; return Fail()

        print("")

    return Fail()


fn {io Io} main()
    print("calculator2")

    data line string
    while {io, line}.readLn()
        data tokens [Item]
        {line, tokens}.lexString()

        switch tokens.parseTokens()
            Success(); print("yarg")
            Fail();   print("argh")
            Finished; print("blarg.")

        line.clear()
            
