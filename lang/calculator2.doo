module calculator2

import ../std/chars
import ../std/io

type Token { TokInt(i64) | TokSym(char) }
type LexResult { null | LexSuccess(Token, i64) }


fn {s string} at(idx i64) { null | char }
    if s[..][idx]
        return conv(s[idx])
    return null

fn {ts [Token]} at(idx i64) { null | Token }
    if ts[..][idx]
        return conv(ts[idx])
    return null

fn {s string} lexInt(idx i64) LexResult
    if s.at(idx) -> char(c) | isDigit(c)
        let n = 0
        while s.at(idx) -> char(c) | isDigit(c)
            n = n*10 + i64(c - '0')
            idx = idx + 1

        return LexSuccess(TokInt(n), idx)
    return null

fn {s string} lexSym(idx i64) LexResult
    if s.at(idx) -> char(c) | c == '+' || c == '*' || c == '(' || c == ')'
        return LexSuccess(TokSym(c), idx + 1)
    return null

fn {s string} lex(idx i64) LexResult
    while s.at(idx) -> char(c) | isSpace(c); idx = idx + 1
    if s.lexInt(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    if s.lexSym(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    return null

fn {s string, tokens [Token]} lexString() bool
    let idx = 0
    while s.lex(idx) -> LexSuccess(token, end)
        idx = end
        tokens.push(token)
    return idx == s.len()

type Item {
    EOF()
    Epsilon()
    E()
    E_()
    T()
    T_()
    F()
    Token
}

type Stack [Item]
type Result { null | Success() }

fn {s Stack} pushDerivation(item Item, lookAhead {null | Token}) bool
    switch (item, lookAhead)
        (EOF(), null);
        (E(), Token(TokSym('(')))
            s.push(E_())
            s.push(T())
        (E(), Token(TokInt(n)))
            s.push(E_())
            s.push(T())
        (E_(), Token(TokSym('+')))
            s.push(E_())
            s.push(T())
            s.push(conv(TokSym('+')))
        (E_(), Token(TokSym(')')))
            s.push(Epsilon())
        (E_(), null)
            s.push(Epsilon())
        (T(), Token(TokSym('(')))
            s.push(T_())
            s.push(F())
        (T(), Token(TokInt(n)))
            s.push(T_())
            s.push(F())
        (T_(), Token(TokSym('+')))
            s.push(Epsilon())
        (T_(), Token(TokSym('*')))
            s.push(T_())
            s.push(F())
            s.push(conv(TokSym('*')))
        (T_(), Token(TokSym(')')))
            s.push(Epsilon())
        (T_(), null)
            s.push(Epsilon())
        (F(), Token(TokSym('(')))
            s.push(conv(TokSym(')')))
            s.push(E())
            s.push(conv(TokSym('(')))
        _; return false
    return true


fn printItem(item Item)
    switch item
        EOF(); print("EOF")
        Epsilon(); print("Epsilon")
        E(); print("E")
        E_(); print("E_")
        T(); print("T")
        T_(); print("T_")
        F(); print("F")


fn {io Io} main()
    data line string
    while {io, line}.readLn()
        data tokens [Token]
        let cursor = 0
        if {line, tokens}.lexString()
            data stack Stack
            stack.push(EOF())
            stack.push(E())

            while stack.len() > 0
                switch stack.pop() 
                    Token(TokSym(sym))
                        if tokens.at(cursor) -> Token(TokSym(s2)) | sym == s2
                            cursor = cursor + 1
                            print("did it")
                    Token(TokInt(n))
                        print("did not did it")
                    item
                        printItem(item)
                        stack.pushDerivation(item, tokens.at(cursor))

        else
            print("lex failure")

        line.clear()
        

    print("calculator2")
