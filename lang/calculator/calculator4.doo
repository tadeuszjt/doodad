module calculator4

import ../../std/io
import ../../std/assert
import ../../std/chars

// Parsing mode: LALR1_BY_SLR(1).
// 
// Grammar:
// 
//      0. $accept -> E
//     -----------------
//      1. E -> E '+' T
//      2.    | E '-' T
//      3.    | T
//      4. T -> T '*' D
//      5.    | D
//      6. D -> D '/' F
//      7.    | F
//      8. F -> NUMBER
//      9.    | '(' E ')'
// 
// LALR1_BY_SLR(1) parsing table:
// 
// ┌────┬─────┬─────┬─────┬─────┬─────┬─────┬────────┬─────┬────┬────┬────┬────┐
// │    │ '+' │ '-' │ '*' │ '/' │ '(' │ ')' │ NUMBER │ $   │ E  │ T  │ D  │ F  │
// ├────┼─────┼─────┼─────┼─────┼─────┼─────┼────────┼─────┼────┼────┼────┼────┤
// │ 0  │     │     │     │     │ s6  │     │ s5     │     │ 1  │ 2  │ 3  │ 4  │
// │ 1  │ s7  │ s8  │     │     │     │     │        │ acc │    │    │    │    │
// │ 2  │ r3  │ r3  │ s10 │     │     │ r3  │        │ r3  │    │    │    │    │
// │ 3  │ r5  │ r5  │ r5  │ s12 │     │ r5  │        │ r5  │    │    │    │    │
// │ 4  │ r7  │ r7  │ r7  │ r7  │     │ r7  │        │ r7  │    │    │    │    │
// │ 5  │ r8  │ r8  │ r8  │ r8  │     │ r8  │        │ r8  │    │    │    │    │
// │ 6  │     │     │     │     │ s6  │     │ s5     │     │ 14 │ 2  │ 3  │ 4  │
// │ 7  │     │     │     │     │ s6  │     │ s5     │     │    │ 9  │ 3  │ 4  │
// │ 8  │     │     │     │     │ s6  │     │ s5     │     │    │ 16 │ 3  │ 4  │
// │ 9  │ r1  │ r1  │ s10 │     │     │ r1  │        │ r1  │    │    │    │    │
// │ 10 │     │     │     │     │ s6  │     │ s5     │     │    │    │ 11 │ 4  │
// │ 11 │ r4  │ r4  │ r4  │ s12 │     │ r4  │        │ r4  │    │    │    │    │
// │ 12 │     │     │     │     │ s6  │     │ s5     │     │    │    │    │ 13 │
// │ 13 │ r6  │ r6  │ r6  │ r6  │     │ r6  │        │ r6  │    │    │    │    │
// │ 14 │ s7  │ s8  │     │     │     │ s15 │        │     │    │    │    │    │
// │ 15 │ r9  │ r9  │ r9  │ r9  │     │ r9  │        │ r9  │    │    │    │    │
// │ 16 │ r2  │ r2  │ s10 │     │     │ r2  │        │ r2  │    │    │    │    │
// └────┴─────┴─────┴─────┴─────┴─────┴─────┴────────┴─────┴────┴────┴────┴────┘


type Cell {
    Accept()
    Shift(i64)
    Reduce(i64)
    Goto(i64)
    Empty()
}


type Item {
    TokInt(i64)
    TokSym(char)
    TokEnd()
    State(i64)
    E_(i64)
    E(i64)
    T(i64)
    D(i64)
    F(i64)
}

fn lookupCell(state i64, item Item) Cell
    let array = [
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Goto(1) , Goto(2) , Goto(3) , Goto(4) ]
        [Shift(7) , Shift(8) , Empty()  , Empty()  , Empty() , Empty()  , Empty() , Accept() , Empty() , Empty() , Empty() , Empty() ]
        [Reduce(3), Reduce(3), Shift(10), Empty()  , Empty() , Reduce(3), Empty() , Reduce(3), Empty() , Empty() , Empty() , Empty() ]
        [Reduce(5), Reduce(5), Reduce(5), Shift(12), Empty() , Reduce(5), Empty() , Reduce(5), Empty() , Empty() , Empty() , Empty() ]
        [Reduce(7), Reduce(7), Reduce(7), Reduce(7), Empty() , Reduce(7), Empty() , Reduce(7), Empty() , Empty() , Empty() , Empty() ]
        [Reduce(8), Reduce(8), Reduce(8), Reduce(8), Empty() , Reduce(8), Empty() , Reduce(8), Empty() , Empty() , Empty() , Empty() ]
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Goto(14), Goto(2) , Goto(3) , Goto(4) ]
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Empty() , Goto(9) , Goto(3) , Goto(4) ]
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Empty() , Goto(16), Goto(3) , Goto(4) ]
        [Reduce(1), Reduce(1), Shift(10), Empty()  , Empty() , Reduce(1), Empty() , Reduce(1), Empty() , Empty() , Empty() , Empty() ]
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Empty() , Empty() , Goto(11), Goto(4) ]
        [Reduce(4), Reduce(4), Reduce(4), Shift(12), Empty() , Reduce(4), Empty() , Reduce(4), Empty() , Empty() , Empty() , Empty() ]
        [Empty()  , Empty()  , Empty()  , Empty()  , Shift(6), Empty()  , Shift(5), Empty()  , Empty() , Empty() , Empty() , Goto(13)]
        [Reduce(6), Reduce(6), Reduce(6), Reduce(6), Empty() , Reduce(6), Empty() , Reduce(6), Empty() , Empty() , Empty() , Empty() ]
        [Shift(7) , Shift(8) , Empty()  , Empty()  , Empty() , Shift(15), Empty() , Empty()  , Empty() , Empty() , Empty() , Empty() ]
        [Reduce(9), Reduce(9), Reduce(9), Reduce(9), Empty() , Reduce(9), Empty() , Reduce(9), Empty() , Empty() , Empty() , Empty() ]
        [Reduce(2), Reduce(2), Shift(10), Empty()  , Empty() , Reduce(2), Empty() , Reduce(2), Empty() , Empty() , Empty() , Empty() ]
    ]

    let true = array[..][state]
    let col = 0
    switch item
        TokSym('+'); col = 0
        TokSym('-'); col = 1
        TokSym('*'); col = 2
        TokSym('/'); col = 3
        TokSym('('); col = 4
        TokSym(')'); col = 5
        TokInt(n)  ; col = 6
        TokEnd()   ; col = 7
        E(_)       ; col = 8
        T(_)       ; col = 9
        D(_)       ; col = 10
        F(_)       ; col = 11
        _; {"invalid item"}.assert(false)

    return array[state][col]

fn {stack [Item]} reduce(production i64)
    switch production
        1 // E -> E '+' T
            let State(_)    = stack.pop()
            let T(n1)       = stack.pop()
            let State(_)    = stack.pop()
            let TokSym('+') = stack.pop()
            let State(_)    = stack.pop()
            let E(n2)       = stack.pop()
            stack.push(E(n2 + n1))

        2 // E -> E '-' T
            let State(_)    = stack.pop()
            let T(n1)       = stack.pop()
            let State(_)    = stack.pop()
            let TokSym('-') = stack.pop()
            let State(_)    = stack.pop()
            let E(n2)       = stack.pop()
            stack.push(E(n2 - n1))

        3 // E -> T
            let State(_)    = stack.pop()
            let T(n1)       = stack.pop()
            stack.push(E(n1))

        4 // T -> T '*' D
            let State(_)    = stack.pop()
            let D(n1)       = stack.pop()
            let State(_)    = stack.pop()
            let TokSym('*') = stack.pop()
            let State(_)    = stack.pop()
            let T(n2)       = stack.pop()
            stack.push(T(n2 * n1))

        5 // T -> D
            let State(_)    = stack.pop()
            let D(n1)       = stack.pop()
            stack.push(T(n1))

        6 // D -> D '/' F
            let State(_)    = stack.pop()
            let F(n1)       = stack.pop()
            let State(_)    = stack.pop()
            let TokSym('/') = stack.pop()
            let State(_)    = stack.pop()
            let D(n2)       = stack.pop()
            print("BLAKG", n2, n1)
            stack.push(D(n2 / n1))

        7 // D -> F
            let State(_)    = stack.pop()
            let F(n1)       = stack.pop()
            stack.push(D(n1))

        8 // F -> NUMBER
            let State(_)    = stack.pop()
            let TokInt(n)   = stack.pop()
            stack.push(F(n))

        9 // F -> '(' E ')'
            let State(_)    = stack.pop()
            let TokSym(')') = stack.pop()
            let State(_)    = stack.pop()
            let E(n)        = stack.pop()
            let State(_)    = stack.pop()
            let TokSym('(') = stack.pop()
            stack.push(F(n))


fn {stack [Item]} printStack()
    for stack -> item
        switch item
            TokSym(c); print(c)
            TokInt(n); print(n)
            E(n); print("E", n)
            F(n); print("F", n)
            D(n); print("D", n)
            T(n); print("T", n)
            State(n); print("state:", n)


fn isRule(item Item) bool
    switch item
        E_(_); return true
        E(_); return true
        T(_); return true
        D(_); return true
        F(_); return true
        _; return false


fn {io Io} main()
    print("calculator4")

    data line string "10 + 2 - 3 - 3"
    data tokens [Item]
    if !{line, tokens}.lexString()
        {"failed to lex"}.assert(false)

    data stack [Item]
    stack.push(State(0))
    let tokenCursor = 0

    for [0..100]
        let token = tokens.at(tokenCursor)
        let item = token
        let state = 0

        // if top of stack is a state, lookup token
        // else get state and item from stack
        switch stack[stack.len() - 1]
            State(s)
                state = s
                item = token
            x | isRule(x)
                item = x
                let State(s) = stack[stack.len() - 2]
                state = s
            _; {"don't know what to do"}.assert(false)


        switch lookupCell(state, item)
            Shift(state) // Push token onto stack, increase tokenCursor, push next state
                print("-- shifting", state)
                stack.push(tokens[tokenCursor])
                stack.push(State(state))
                tokenCursor = tokenCursor + 1

            Reduce(production) // pop state, replace RHS of production with LHS
                print("-- reducing", production)
                stack.reduce(production)

            Goto(state) // push next state
                print("-- goto", state)
                stack.push(State(state))

            Accept()
                print("-- accept")
                let TokEnd() = token
                return

            _; {"invalid cell"}.assert(false)

        stack.printStack()



type LexResult { null | LexSuccess(Item, i64) }

fn {tokens [Item]} at(idx i64) Item
    if idx == tokens.len(); return TokEnd()
    else if idx < tokens.len(); return tokens[idx]
    let true = false
    print("tokens.at error")
    return TokEnd()

fn {s string} at(idx i64) { null | char }
    if s[..][idx]
        return conv(s[idx])
    return null

fn {s string} lexInt(idx i64) LexResult
    if s.at(idx) -> char(c) | isDigit(c)
        let n = 0
        while s.at(idx) -> char(c) | isDigit(c)
            n = n*10 + i64(c - '0')
            idx = idx + 1

        return LexSuccess(TokInt(n), idx)
    return null

fn {s string} lexSym(idx i64) LexResult
    if s.at(idx) -> char(c) | c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')'
        return LexSuccess(TokSym(c), idx + 1)
    return null

fn {s string} lex(idx i64) LexResult
    while s.at(idx) -> char(c) | isSpace(c); idx = idx + 1
    if s.lexInt(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    if s.lexSym(idx) -> LexSuccess(a, b); return LexSuccess(a, b)
    return null

fn {s string, tokens [Item]} lexString() bool
    let idx = 0
    while s.lex(idx) -> LexSuccess(token, end)
        idx = end
        tokens.push(token)
    return idx == s.len()

