module qbegen

import ../../std/io

type Name {
    Local(@string)
    Global(@string)
    Aggregate(i64)
    Block(@string)
}

type Type {
    Long()
    Word()
    Single()
    Double()
    SignedByte()
    Named(i64)
    Opaque(i64)
    Struct(@[Type])
}

type Value {
    Name
    Const(i64)
}

type Stmt {
    StmtAdd(Name, Type, Name, Name)
    StmtCopy(Name, Type, i64)
    StmtCallVoid(@string, @[(Type, Value)])
}

type Terminator {
    Ret(Value)
    RetVoid()
    Hlt()
}


fn {io Io, strings sparse[string]} writeValue(value Value)
    switch value
        Name(name); {io, strings}.writeName(name)
        Const(n)  ; io.write(n)


fn {io Io} writeType(typ Type)
    switch typ
        Long(); io.write('l')
        Word(); io.write('w')
        Single(); io.write('s')
        Double(); io.write('d')
        SignedByte(); io.write("sb")


fn {io Io, strings sparse[string]} writeName(name Name)
    switch name
        Local(key); io.write("%", strings[key])
        Global(key); io.write("$", strings[key])
        Block(key); io.write("@", strings[key])


fn {io Io, strings sparse[string]} writeTerminator(terminator Terminator)
    io.write('\t')
    switch terminator
        Ret(value)
            io.write("ret ")
            {io, strings}.writeValue(value)
        RetVoid(); io.write("ret")
    io.write('\n')


fn {io Io, strings sparse[string], args sparse[[(Type, Value)]]} writeStmt(stmt Stmt)
    io.write('\t')
    switch stmt
        StmtAdd(n1, t1, n2, n3)
            {io, strings}.writeName(n1)
            io.write(" =")
            io.writeType(t1)
            io.write(" add ")
            {io, strings}.writeName(n2)
            io.write(", ")
            {io, strings}.writeName(n3)
        StmtCopy(name, typ, int)
            {io, strings}.writeName(name)
            io.write(" =")
            io.writeType(typ)
            io.write(" copy ", int)
        StmtCallVoid(nameId, argsId)
            io.write("call $")
            io.write(strings[nameId])
            io.write('(')
            for args[argsId] -> (t, v)
                io.writeType(t)
                io.write(' ')
                {io, strings}.writeValue(v)
                io.write(", ")
            io.write(')')
    io.write('\n')


fn {io Io, strings sparse[string]} writeBlock(name Name)
    let Block(_) = name
    {io, strings}.writeName(name)
    io.write('\n')


fn {io Io} writeFuncStart(retty Type)
    io.write("export\n")
    io.write("function ")
    io.writeType(retty)
    io.write(" $main() {\n")


fn {io Io} writeFuncEnd()
    io.write("}\n")


fn {io Io} writeTypeDef(typ Type)
    io.write("type :fourFLoats = ")
    io.writeType(typ)
    io.write('\n')


fn {io Io} main()
    data strings sparse[string]
    let putcharId = strings.push("putchar")
    let blockId   = Block(strings.push("start"))
    let local0    = Local(strings.push("a"))
    let local1    = Local(strings.push("b"))
    let local2    = Local(strings.push("c"))

    io.writeFuncStart(Word())
    {io, strings}.writeBlock(blockId)

    data args sparse[[(Type, Value)]]
    let argsId = args.push( [(SignedByte(), Const(44))] )

    for [
        StmtCopy(local0, Word(), 40)
        StmtCopy(local1, Word(), 2)
        StmtAdd(local2, Word(), local0, local1)
        StmtCallVoid(putcharId, argsId)
    ] -> stmt; {io, strings, args}.writeStmt(stmt)

    {io, strings}.writeTerminator(Ret(Const(0)))
    io.writeFuncEnd()


