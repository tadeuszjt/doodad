module ox

import ../std/io
import ../std/strings
import ../std/array
import ../std/integer
import ../std/bool

type Empty Tuple{}
type Naught Tuple{}
type Cross Tuple{}

type Square Sum{
    Empty,
    Naught,
    Cross,
}

type Board Tuple{
    Square.Array{3}.Array{3}
}

type Move Tuple{I64, I64}
type Quit Tuple{}
type Error Tuple{}
type Input Sum{
    Move,
    Quit,
    Error
}


fn construct() Quit
    let q : Quit
    return q

fn construct() Error
    let e : Error
    return e

fn construct() Empty
    let e : Empty
    return e

fn construct(x I64, y I64) Move
    let m : Move
    m.0 = x
    m.1 = y
    return m

fn construct(q Quit) Input; return conv(q)
fn construct(m Move) Input; return conv(m)
fn construct(e Error) Input; return conv(e)
fn construct(e Empty) Square; return conv(e)

fn equal(a Square, b Square) Bool
    switch (a, b)
        (Empty(), Empty());   return true
        (Naught(), Naught()); return true
        (Cross(), Cross());   return true
        _;                    return false



fn at(board &Board, index I64) &Square.Array{3}; return (board.0).at(index)
fn len(board &Board)           I64; return (board.0).len

fn set(a &Square, b Square)
    ${ memcpy($a, &$b, sizeof($b)); }

fn set(a &Empty, b Empty); return
fn set(a &Quit, b Quit); return
fn set(a &Error, b Error); return

fn set(a &Move, b Move)
    a.0 = b.0
    a.1 = b.1

fn set(a &Board, b Board)
    for (0, a.len) -> i
        a[0] = b[0]



fn printBoard(io &Io, board Board)
    for board.0 -> row
        io.stdout += '['

        for (0, row.len) -> col

            switch row[col]
                Empty();  io.stdout += ' '
                Naught(); io.stdout += 'O'
                Cross();  io.stdout += 'X'

            if col < (row.len - 1)
                io.stdout += ", "

        io.stdout += "]"
        io.stdout += '\n'


fn winner(board Board) Square
    // check for horizontal lines
    for board.0 -> row
        let match = true

        for row -> square
            if square != row[0]
                match = false

        if match && row[0] != Square(Empty())
            return row[0]

    // check for vertical lines
    for (0, board[0].len) -> col
        let match = true
        for (0, board.len) -> row
            if board[row][col] != board[0][col]
                match = false
        if match && board[0][col] != Square(Empty())
            return board[0][col]

    // check diagonals
//    if b -> [ [a, _, _], [_, b, _], [_, _, c] ] | a == b && b == c
//        return a
//    if b -> [ [_, _, a], [_, b, _], [c, _, _] ] | a == b && b == c
//        return a
//
    return Square(Empty())





fn getPlayerInput(io &Io) Input
    io.stdout.append("Please enter move: <row> <col>").append('\n')
    
    data line Char.Table
    if !io.stdin.getLine(&line)
        return Input(Quit())

    let row = 0
    let col = 0
    let idx = 0

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        row = n
        idx = idx + num
    else
        return Input(Error())

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        col = n
        idx = idx + num
    else
        return Input(Error())

    return Input(Move(row, col))


fn main()
    data io Io
    io.stdout += "naughts and crosses"
    io.stdout += '\n'

    let board : Board
    io.printBoard(board)

    while winner(board) == Square(Empty())
        switch io.getPlayerInput()
            Quit(); return
            Error()
                io.stdout.append("parse error").append('\n')
            Move((row, col))
                io.stdout += "moving "
                io.stdout += row
                io.stdout += ", "
                io.stdout.append(col).append('\n')

        io.printBoard(board)
        return

