module ox

import std/io
import std/strings
import std/array
import std/integer
import std/bool
import std/push
import std/table
import std/tuple

type Empty Tuple{}
type Naught Tuple{}
type Cross Tuple{}

type Square Sum{
    Empty,
    Naught,
    Cross,
}

type Board Tuple{
    Square.Array{3}.Array{3}
}

type Move Tuple{I64, I64}
type Quit Tuple{}
type Error Tuple{}
type Input Sum{
    Move, 
    Quit, 
    Error 
}


fn error() Input
    let e : Error
    return conv(e)


fn quit() Input
    let q : Quit
    return conv(q)


fn empty() Square
    let e : Empty
    return conv(e)

fn naught() Square
    let n : Naught
    return conv(n)


fn move(x I64, y I64) Input
    let m : Move
    m.0 = x
    m.1 = y
    return conv(m)

fn first(m &Move) &I64; return &m.0
fn second(m &Move) &I64; return &m.1


fn equal(a Square, b Square) Bool
    switch (a, b)
        (Empty(), Empty());   return true
        (Naught(), Naught()); return true
        (Cross(), Cross());   return true
        _;                    return false

fn at(board &Board, index I64) &Square.Array{3}; return (board.0).at(index)
fn len(board &Board)           I64; return (board.0).len

fn set(a &Square, b Square)
    ${ memcpy($a, &$b, sizeof($b)); }


fn printBoard(io &Io, board Board)
    for board.0 -> row
        io.stdout.push('[')

        for (0, row.len) -> col

            switch row[col]
                Empty();  io.stdout.push(' ')
                Naught(); io.stdout.push('O')
                Cross();  io.stdout.push('X')

            if col < (row.len - 1)
                io.stdout.push(", ")

        io.stdout.push("]", '\n')


fn winner(board Board) Square
    // check for horizontal lines
    for board.0 -> row
        let match = true

        for row -> square
            if square != row[0]
                match = false

        if match && row[0] != empty()
            return row[0]

    // check for vertical lines
    for (0, board[0].len) -> col
        let match = true
        for (0, board.len) -> row
            if board[row][col] != board[0][col]
                match = false

        if match && board[0][col] != empty()
            return board[0][col]

    // check diagonals
//    if b -> [ [a, _, _], [_, b, _], [_, _, c] ] | a == b && b == c
//        return a
//    if b -> [ [_, _, a], [_, b, _], [c, _, _] ] | a == b && b == c
//        return a
//
    return empty()





fn getPlayerInput(io &Io) Input
    io.stdout.push("Please enter move: <row> <col>", '\n')
    
    data line Char.Table
    if !io.stdin.getLine(&line)
        return quit()

    let (row, col, idx) = (0, 0, 0)

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        row = n
        idx = idx + num
    else
        return error()

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        col = n
        idx = idx + num
    else
        return error()

    return move(row, col)


fn main()
    data io Io
    io.stdout.push("naughts and crosses", '\n')

    let board : Board
    io.printBoard(board)

    while winner(board) == empty()

        let moved = false
        while !moved
            switch io.getPlayerInput()
                Quit(); return
                Error()
                    io.stdout.push("parse error", '\n')
                Move((row, col)) | row < 0 || row > (board.len - 1)
                    io.stdout.push("row not in range\n")
                Move((row, col)) | col < 0 || col > (board[0].len - 1)
                    io.stdout.push("col not in range\n")
                Move((row, col))
                    io.stdout.push("moving ", row, ", ", col, '\n')
                    board[row][col] = naught()
                    moved = true

        io.printBoard(board)

    return
