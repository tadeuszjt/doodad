module ox

import std/io
import std/strings
import std/array
import std/integer
import std/bool
import std/push
import std/table
import std/tuple
import std/char
import std/rand
import std/features

type Empty Tuple{}
type Naught Tuple{}
type Cross Tuple{}

type Square Sum{
    Empty,
    Naught,
    Cross,
}

type Board Tuple{
    Square.Array{3}.Array{3}
}

type Move Tuple{I64, I64}
type Quit Tuple{}
type Error Tuple{}
type Input Sum{
    Move, 
    Quit, 
    Error 
}



fn error()  Input;  return conv(builtin_zero():Error)
fn quit()   Input;  return conv(builtin_zero():Quit)
fn empty()  Square; return conv(builtin_zero():Empty)
fn naught() Square; return conv(builtin_zero():Naught)
fn cross()  Square; return conv(builtin_zero():Cross)

fn move(x I64, y I64) Input
    let m : Move
    m.0 = x
    m.1 = y
    return conv(m)

fn first(m &Move) &I64; return &m.0
fn second(m &Move) &I64; return &m.1


fn Compare::equal(a Square, b Square) Bool
    switch (a, b)
        (Empty(), Empty());   return true
        (Naught(), Naught()); return true
        (Cross(), Cross());   return true
        _;                    return false

fn At::at(board &Board, index I64) &Square.Array{3}
    return (board.0).at(index)

fn Len::len(board &Board) I64; return (board.0).len

fn set(a &Board, b Board)
    for (0, a.len) -> row
        for (0, a[row].len) -> col
            a[row][col] = b[row][col]


fn set(a &Square, b Square)
    ${ memcpy($a, &$b, sizeof($b)); }


fn push(stdout &StdOut, square Square)
    switch square
        Empty(); stdout.push(' ')
        Naught(); stdout.push('O')
        Cross(); stdout.push('X')


fn printBoard(io &Io, board Board)
    for board.0 -> row
        io.stdout.push('[')

        for (0, row.len) -> col
            io.stdout.push(row[col])
            if col < (row.len - 1)
                io.stdout.push(", ")

        io.stdout.push("]", '\n')


fn winner(board Board) Square
    // check for horizontal lines
    for board.0 -> row
        let match = true

        for row -> square
            if square != row[0]
                match = false

        if match && row[0] != empty()
            return row[0]

    // check for vertical lines
    for (0, board[0].len) -> col
        let match = true
        for (0, board.len) -> row
            if board[row][col] != board[0][col]
                match = false

        if match && board[0][col] != empty()
            return board[0][col]

    // check diagonals
    let match = true
    for (0, board.len) -> i | match
        if board[i][i] != board[0][0]
            match = false
    if match && board[0][0] != empty()
        return board[0][0]

    match = true
    for (0, board.len) -> i | match
        let row = board.len - 1 - i
        if board[row][i] != board[board.len - 1][0]
            match = false
    if match && board[board.len - 1][0] != empty()
        return board[board.len - 1][0]

    return empty()


fn getPlayerInput(io &Io) Input
    io.stdout.push("Please enter move: <row> <col>", '\n')
    
    data line Char.Table
    if !io.stdin.getLine(&line)
        return quit()

    let (row, col, idx) = (0, 0, 0)

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        row = n
        idx = idx + num
    else
        return error()

    if readI64(line.slice(idx, line.len)) -> (I64, I64)( (n, num) )
        col = n
        idx = idx + num
    else
        return error()

    return move(row, col)


fn cpuMove(io &Io, board &Board)
    io.stdout.push("cpu moving ...", '\n')

    // find all empty squares
    data empty (I64, I64).Table
    for (0, board.len) -> row
        for (0, board[row].len) -> col
            if board[row][col] == empty()
                empty.push( (row, col) )

    if empty.len == 0
        io.stdout.push("cpu can't move\n")
        return


    // find move that wins
    for empty -> (row, col)
        board[row][col] = cross()
        if winner(board) == cross()
            return
        board[row][col] = empty()


    // find move that opponent wins
    for empty -> (row, col)
        board[row][col] = naught()
        if winner(board) == naught()
            board[row][col] = cross()
        else
            board[row][col] = empty()


    // choose random move
    data rand Rand
    let i = rand.i64(0, empty.len)
    let (row, col) = empty[i]
    board[row][col] = cross()


fn main()
    data io Io
    io.stdout.push("naughts and crosses", '\n')

    let board : Board
    io.printBoard(board)

    while winner(board) == empty()
        let moved = false
        while !moved
            switch io.getPlayerInput()
                Quit(); return
                Error()
                    io.stdout.push("parse error", '\n')
                Move((row, col)) | row < 0 || row > (board.len - 1)
                    io.stdout.push("row not in range\n")
                Move((row, col)) | col < 0 || col > (board[0].len - 1)
                    io.stdout.push("col not in range\n")
                Move((row, col))
                    io.stdout.push("moving ", row, ", ", col, '\n')
                    board[row][col] = naught()
                    moved = true

        io.cpuMove(&board)
        io.printBoard(board)

    io.stdout.push("winner: ", winner(board), '\n')

