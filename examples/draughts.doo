module draughts

import ../std/io
import ../std/strings
import ../std/chars


type Square { Empty() | White() | Black() }
type Board  [8 [8 Square]]
type Pos    (row i64, col i64)
type Move   (start Pos, end Pos)

fn {board Board} Contains(p Pos) bool
    return board[..][p.row] && board[p.row][..][p.col]


fn {board Board, list [Move]} GetValidMoves()
    data positions [Pos]
    for board[..] -> r
        for board[r][..] -> c
            if board[r][c] != Empty()
                positions.push(Pos(r, c))

    data whitePositions [Pos]
    data blackPositions [Pos]
    for positions -> pos
        if board[pos.row][pos.col] == White()
            whitePositions.push(pos)
        if board[pos.row][pos.col] == Black()
            blackPositions.push(pos)

    data whiteMoves [Move]
    for whitePositions -> pos
        data potentialMovesEmpty [2 Pos]
        potentialMovesEmpty[0] = Pos(pos.row + 1, pos.col + 1)
        potentialMovesEmpty[1] = Pos(pos.row + 1, pos.col - 1)

        for potentialMovesEmpty -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                whiteMoves.push((pos, pm))

        data potentialMovesTake [2 Pos]
        potentialMovesTake[0] = Pos(pos.row + 2, pos.col + 2)
        potentialMovesTake[1] = Pos(pos.row + 2, pos.col - 2)

        for potentialMovesTake -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                if board[(pm.row + pos.row) / 2][(pm.col + pos.col) / 2] == Black()
                    whiteMoves.push((pos, pm))

    data blackMoves [Move]
    for blackPositions -> pos
        data potentialMovesEmpty [2 Pos]
        potentialMovesEmpty[0] = Pos(pos.row - 1, pos.col + 1)
        potentialMovesEmpty[1] = Pos(pos.row - 1, pos.col - 1)
        for potentialMovesEmpty -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                blackMoves.push((pos, pm))

        data potentialMovesTake [2 Pos]
        potentialMovesTake[0] = Pos(pos.row - 2, pos.col + 2)
        potentialMovesTake[1] = Pos(pos.row - 2, pos.col - 2)
        for potentialMovesTake -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                if board[(pm.row + pos.row) / 2][(pm.col + pos.col) / 2] == White()
                    blackMoves.push((pos, pm))

    for blackMoves -> move
        list.push(move)

    for whiteMoves -> move
        list.push(move)


fn {board Board} Print()
    for board[..] -> r
        putChar('0' + board.len() - char(r))
        putStr(" [")
        for board[r][..] -> c
            switch board[r][c]
                Empty(); putChar(' ')
                White(); putChar('W')
                Black(); putChar('B')
            if [.. board[r].len() - 1][c]; putChar(',') 
        putStrLn("]")
    putStrLn("   A B C D E F G H")


fn {board Board} Initialise()
    for board[..3] -> r
        let c = 0
        if r % 2 == 0; c = 1
        while board[r][..][c]
            board[r][c] = White()
            c = c + 2

    for board[board.len() - 3 .. ] -> r
        let c = 0
        if r % 2 == 0; c = 1
        while board[r][..][c]
            board[r][c] = Black()
            c = c + 2


fn {board Board} playerMove()
    print("Enter move. Eg: E2 E4")
    data line String
    line.GetStrLn()

    let (startColChar, n1) = line.ReadChar(0)
    let (startRow, n2)     = line.ReadI64(n1)
    let (endColChar, n3)   = line.ReadChar(n1 + n2)
    let (endRow, n4)       = line.ReadI64(n1 + n2 + n3)
    if n1 == 0 || n2 == 0 || n3 == 0 || n4 == 0
        print("invalid move")
        return

    let startCol = i64(chars::toLower(startColChar) - 'a')
    let endCol   = i64(chars::toLower(endColChar) - 'a')

    let start = Pos(startRow, startCol)
    let end   = Pos(endRow, endCol)
    if !board.Contains(start) || !board.Contains(end)
        print("out of range", start, end)


    if board[startRow][startCol] == Black()
        print("start is black")
    else 
        print("start isnt black")


    data moves [Move]
    {board, moves}.GetValidMoves()

    print("moves: ", moves)
    print(startCol, startRow, endCol, endRow)
    return


fn main()
    data board Board
    board.Initialise()
    board.Print()
    board.playerMove()
    board.Print()
