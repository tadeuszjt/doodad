module draughts

import ../std/io
import ../std/strings
import ../std/chars
import ../std/rand
import ../std/maths


type Square { Empty() | White() | Black() }
type Board  [8 [8 Square]]
type Pos    (row i64, col i64)
type Move   (start Pos, end Pos)


fn {board Board} Contains(p Pos) bool
    return board[..][p.row] && board[p.row][..][p.col]


fn {board Board, list [Move]} GetValidMoves(team Square)
    data positions [Pos]
    for board[..] -> r
        for board[r][..] -> c
            if board[r][c] == team
                positions.push(Pos(r, c))

    let rowAdvance = 0
    switch team
        White(); rowAdvance = 1
        Black(); rowAdvance = -1

    data moves [Move]
    for positions -> pos
        data potentialMovesEmpty [2 Pos]
        potentialMovesEmpty[0] = Pos(pos.row + rowAdvance, pos.col + 1)
        potentialMovesEmpty[1] = Pos(pos.row + rowAdvance, pos.col - 1)

        for potentialMovesEmpty -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                moves.push((pos, pm))

        data potentialMovesTake [2 Pos]
        potentialMovesTake[0] = Pos(pos.row + rowAdvance*2, pos.col + 2)
        potentialMovesTake[1] = Pos(pos.row + rowAdvance*2, pos.col - 2)

        for potentialMovesTake -> pm
            if board.Contains(pm) && board[pm.row][pm.col] == Empty()
                if board[(pm.row + pos.row) / 2][(pm.col + pos.col) / 2] -> sq | sq != Empty() && sq != team
                    moves.push((pos, pm))

    for moves -> move
        list.push(move)


fn {board Board} MakeMove(move Move) bool
    if !board.Contains(move.start) || !board.Contains(move.end)
        print("invalid move", move)
        return false
    board[move.end.row][move.end.col] = board[move.start.row][move.start.col]
    board[move.start.row][move.start.col] = Empty()

    let rowDist = abs(move.end.row - move.start.row)
    let colDist = abs(move.end.col - move.start.col)
    switch (rowDist, colDist)
        (1, 1);
        (2, 2); board[(move.start.row + move.end.row) / 2][(move.start.col + move.end.col) /2] = Empty()
        _
            print("MakeMove: invalid move", move)
            return false

    return true


fn {board Board, io Io} Print()
    for board[..] -> r
        io.putChar(char(r) + '0')
        io.putStr(" [")
        for board[r][..] -> c
            switch board[r][c]
                Empty(); io.putChar(' ')
                White(); io.putChar('W')
                Black(); io.putChar('B')
            if [.. board[r].len() - 1][c]; io.putChar(',') 
        io.putStrLn("]")
    io.putStrLn("   A B C D E F G H")


fn {board Board} Initialise()
    for board[..3] -> r
        let c = 0
        if r % 2 == 0; c = 1
        while board[r][..][c]
            board[r][c] = White()
            c = c + 2

    for board[board.len() - 3 .. ] -> r
        let c = 0
        if r % 2 == 0; c = 1
        while board[r][..][c]
            board[r][c] = Black()
            c = c + 2


fn {io Io} playerMove() Move
    print("Enter move. Eg: E2 E4")
    data line String
    {line, io}.GetStrLn()

    let (startColChar, n1) = line.ReadChar(0)
    let (startRow, n2)     = line.ReadI64(n1)
    let (endColChar, n3)   = line.ReadChar(n1 + n2)
    let (endRow, n4)       = line.ReadI64(n1 + n2 + n3)
    if n1 == 0 || n2 == 0 || n3 == 0 || n4 == 0
        print("invalid parse")
        return Move()

    let startCol = i64(chars::toLower(startColChar) - 'a')
    let endCol   = i64(chars::toLower(endColChar) - 'a')
    let start    = Pos(startRow, startCol)
    let end      = Pos(endRow, endCol)
    return Move(start, end)


fn {board Board, rand Rand} CpuMove(team Square) Move
    data valid [Move]
    {board, valid}.GetValidMoves(team)

    if valid.len() == 0
        print("CpuMove: no moves available")
        return Move()

    for valid -> move
        if abs(move.end.row - move.start.row) == 2
            return move

    return valid[rand.I64() % valid.len()]


fn {board Board, io Io} playerMoveLoop() Move
    while true
        data valid [Move]
        {board, valid}.GetValidMoves(Black())
        let move = io.playerMove()

        let moveIsValid = false
        for valid -> m | !moveIsValid
            moveIsValid = m == move

        if !moveIsValid
            print("invalid move: ", move)
        else; return move



fn main()
    data io Io
    data board Board
    data rand Rand

    board.Initialise()
    {board, io}.Print()

    print(abs(-0.2))

    let loop = true
    while loop
        print()
        print("cpu move: ")
        let cpuMove = {board, rand}.CpuMove(White())
        board.MakeMove(cpuMove)
        {board, io}.Print()

        let loop = true
        print("player move: ")
        let move = {board, io}.playerMoveLoop()
        board.MakeMove(move)
        {board, io}.Print()



