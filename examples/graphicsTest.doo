module graphicsTest

import std/io
import std/sfml/sfml
import std/rand
import std/sparse
import std/print
import std/option
import std/store
import std/builtin
import std/for
import std/assert
import std/arithmetic
import std/tuple
import std/container
import std/unordered
import std/convert


tuple Blob {
    position Vec2f
    velocity Vec2f
    quadKey  unordered::Key{Quad}
}
derives Blob (store)


fn setQuadPosition(quads &Quad.Unordered, key unordered::Key{Quad}, position Vec2f)
    quads[key][0] = (position + (-10.0, -10.0), black(), (0.0, 0.0)):Vertex
    quads[key][1] = (position + (10.0, -10.0),  black(), (0.0, 0.0)):Vertex
    quads[key][2] = (position + (10.0, 10.0),   black(), (0.0, 0.0)):Vertex
    quads[key][3] = (position + (10.0, -10.0),  black(), (0.0, 0.0)):Vertex
    quads[key][4] = (position + (10.0, 10.0),   black(), (0.0, 0.0)):Vertex
    quads[key][5] = (position + (-10.0, 10.0),  black(), (0.0, 0.0)):Vertex


//fn {t Triangles} addTriangle(position Vec2f) Key[I64]
//    let key = t.vertexes.len()
//    t.vertexes.push( (position + (0, -10),  green(),   (0, 0)) )
//    t.vertexes.push( (position + (-10, 10), green(), (0, 0)) )
//    t.vertexes.push( (position + (10, 10),  green(),  (0, 0)) )
//    return t.vertexKeys.insert(key)
//
//
//fn {t Triangles} setTrianglePosition(key Key[I64], pos Vec2f)
//    let index = t.vertexKeys.get(key)
//    let {p, _, _} = t.vertexes.at(index + 0) in; p = pos + (0, -10)
//    let {p, _, _} = t.vertexes.at(index + 1) in; p = pos + (-10, 10)
//    let {p, _, _} = t.vertexes.at(index + 2) in; p = pos + (10, 10)
//
// TODO Broken
//fn vec2f(rand &Rand) Vec2f
//    return (rand.f32(convert(0.0), convert(5000.0)), rand.f32(convert(0.0), convert(5000.0))).pretend

//fn {rand Rand} vec2f(min Vec2f, max Vec2f) Vec2f
//    return (rand.f32(min.x, max.x), rand.f32(min.y, max.y))
//
//
fn main()
    data io Io
    io.stdout.print("graphics test\n")

    let rand:Rand
    let w:Window

    w.create()


//    data triangles Triangles
    data blobs Blob.Table
    data quads Quad.Unordered

    for (0, 1)
        let blob:Blob
        //blob.position = rand.vec2f()
        blob.position = (50.0, 50.0)
        blob.quadKey = quads.unordered::insertZero
        quads.setQuadPosition(blob.quadKey, (0.0, 0.0))
        blobs.push(blob)

    io.stdout.print(quads)


    while w.isOpen()
//        let prevNs = time::getTimestampNs()
//
        while w.pollEvent() -> some(event)
            switch event
                closed(); w.close()
                //none();
                _;

        for (0, blobs.len) -> i
            blobs[i].position = blobs[i].position + blobs[i].velocity


//        let nextNs = time::getTimestampNs()
//
//        print("process time:", nextNs - prevNs)
//
//        let diff = nextNs - prevNs
//        //sleepNs(15600000 - diff)
//        
//
//        prevNs = time::getTimestampNs()
//
//        let (width, height) = w.getSize()
//        w.setViewFromRect(((0, 0), (conv(width), conv(height))))
        w.clearWindow(white())
        w.drawQuads(quads.Unordered::values)
        w.display()
//
//        nextNs = time::getTimestampNs()
//        print("render time: ", nextNs - prevNs)
//
    w.destroy()



