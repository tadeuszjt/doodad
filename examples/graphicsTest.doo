module graphicsTest

import std/io
import std/sfml/sfml
import std/rand
import std/sparse
import std/print
import std/option
import std/store
import std/builtin
import std/for
import std/assert
import std/arithmetic
import std/tuple
import std/container
import std/unordered
import std/convert


tuple Blob {
    position Vec2f
    velocity Vec2f
    quadKey  unordered::Key{Quad}
}
derives Blob (store)


type Triangle Array{3, sfml::Vertex}

type Quad Array{2, Triangle}


//fn setQuadPosition(quads &Quad.Unordered, key unordered::Key{Quad}, position Vec2f) {
//    quads[key][0][0] = sfml::vertex(vec2f(position.x - convert(10.0)
//}

//fn {t Triangles} addTriangle(position Vec2f) Key[I64]
//    let key = t.vertexes.len()
//    t.vertexes.push( (position + (0, -10),  green(),   (0, 0)) )
//    t.vertexes.push( (position + (-10, 10), green(), (0, 0)) )
//    t.vertexes.push( (position + (10, 10),  green(),  (0, 0)) )
//    return t.vertexKeys.insert(key)
//
//
//fn {t Triangles} setTrianglePosition(key Key[I64], pos Vec2f)
//    let index = t.vertexKeys.get(key)
//    let {p, _, _} = t.vertexes.at(index + 0) in; p = pos + (0, -10)
//    let {p, _, _} = t.vertexes.at(index + 1) in; p = pos + (-10, 10)
//    let {p, _, _} = t.vertexes.at(index + 2) in; p = pos + (10, 10)
//
// TODO Broken
//fn vec2f(rand &Rand) Vec2f
//    return (rand.f32(convert(0.0), convert(5000.0)), rand.f32(convert(0.0), convert(5000.0))).pretend

//fn {rand Rand} vec2f(min Vec2f, max Vec2f) Vec2f
//    return (rand.f32(min.x, max.x), rand.f32(min.y, max.y))
//
//
fn main()
    data io Io
    io.stdout.print("graphics test\n")

    let rand:Rand
    let w:Window

    w.create()

//    data triangles Triangles
    data blobs Blob.Table
    data quads Quad.Unordered

    for (0, 10)
        let blob:Blob
        //blob.position = rand.vec2f()
        blob.position = vec2f(1.0, 0.0)
        blob.quadKey = quads.unordered::insertZero
        blobs.push(blob)


//    for (0, 100000)
//        let blob:()Blob
//        blob.position    = rand.vec2f()
//        blob.velocity    = rand.vec2f( (-0.5, -0.5), (0.5, 0.5) )
//        blob.triangleKey = triangles.addTriangle( blob.position )
//        blobs.push(blob)


    while w.isOpen()
//        let prevNs = time::getTimestampNs()
//
        while w.pollEvent() -> some(event)
            switch event
                closed(); w.close()
                //none();
                _;

        for (0, blobs.len) -> i
            blobs[i].position = blobs[i].position + blobs[i].velocity


//        let nextNs = time::getTimestampNs()
//
//        print("process time:", nextNs - prevNs)
//
//        let diff = nextNs - prevNs
//        //sleepNs(15600000 - diff)
//        
//
//        prevNs = time::getTimestampNs()
//
//        let (width, height) = w.getSize()
//        w.setViewFromRect(((0, 0), (conv(width), conv(height))))
//        w.clearWindow(white())
//        {w, triangles.vertexes}.drawPrimitives()
//        w.display()
//
//        nextNs = time::getTimestampNs()
//        print("render time: ", nextNs - prevNs)
//
    w.destroy()



