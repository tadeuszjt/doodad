module langTest

import std/table
import std/sparse
import std/unordered
import std/maybe
import std/binaryTree
import std/map
import std/io
import std/array
import std/tuple
import std/integer
import std/floating
import std/char
import std/sum
import std/slice
import std/push
import std/bool
import std/features


fn testArithmetic()
    let x = 1 + 2
    let 3 = x

fn testFloats()
    let x = 1.0 + 2.0
    let 3.0 = x
    let 4.0 = 16.0 / 4.0


fn testConvert()
    let 3 = 1 + 2
    type MyInt I64

    fn Store::store(a &MyInt, b MyInt); ${ *$a = $b; }
    fn Arithmetic::add(a MyInt, b MyInt) MyInt
        let c : MyInt
        ${ $c = $a + $b; }
        return c
    fn Compare::equal(a MyInt, b MyInt) Bool
        let c : Bool
        ${ $c = $a == $b; }
        return c

    fn Construct::construct(a I64) MyInt
        let b : MyInt
        ${ $a = $b; }
        return b

    let 1 : MyInt = add(0, 1)

    let x : MyInt = 3
    let 4 : MyInt = 1 + x
    
    let f = 3.14
    let 3 = I64(f)
    return


fn testIf()
    let x = 3
    if x == 3
        let true = true
    else
        let false = true


fn testSwitch()
    let x = 0
    switch 10
        x | x == 0; let true = false
        y | y == 10; x = 1
        _; let true = false

    let 1 = x


fn testLet()
    let x = 1 in
        x = 2
    let x = 4


fn testTuple()
    let x = (1, true)
    let (1, true) = x
    if x -> (1, false)
        let true = false
    let (3, 4, 5) = (1, 2, 3) + (2, 2, 2)


fn testFnWithRef()
    fn f(a &I64)
        a = a + 1
    let x = 1
    f(&x)
    let 2 = x

    fn g(a &I64) &I64
        a = a + 1
        return &a
    let y = 34
    g(&y)
    let 35 = y
    g(&y) = 0
    let 0 = y

    fn h(a &(I64, I64))
        a = (1, 2)
    let z = (0, 0)
    h(&z)
    let (1, 2) = z


fn testTable()
    data table I64.Table

    let 0 = table.len
    table.push(1, 2, 3)

    let 3 = table.len
    let 1 = table.at(0)

    let 2 = table.at(1)
    builtin_table_at(&table, 1) = 3
    let 3 = builtin_table_at(&table, 1)

    let 3 = table.pop
    let 3 = table.pop
    let 1 = table.pop
    let 0 = table.len

    type Person (I64, Bool)
    fn Store::store(a &Person, b Person)
        a.0 = b.0
        a.1 = b.1

    fn first(p &Person) &I64; return &p.0
    fn second(p &Person) &Bool; return &p.1
    fn Construct::construct(a I64, b Bool) Person
        let p : Person
        p.first = a
        p.second = b
        return p


    data t2 Person.Table

    t2.push( Person(1, true) )
    t2.push( Person(2, false) )

    let 2 = t2.len

    t2.at(1) = (3, true)
    let (3, true) = t2.pop

    data m3 I64.Table.Table
    let 0 = m3.len
    m3.push
    m3[0].push
    let 1 = m3[0].len


fn testSparse()
    data s1 I64.Sparse

    let 0 = s1.len
    let k1 = s1.insert
    let k2 = s1.insert
    let k3 = s1.insert
    let 3 = s1.len

    s1.at(k1) = 1
    s1.at(k2) = 2
    s1.at(k3) = 3

    let 1 = s1.at(k1)
    let 2 = s1.at(k2)
    let 3 = s1.at(k3)

    s1.delete(k2)
    let 2 = s1.len
    let 1 = s1.at(k1)
    let 3 = s1.at(k3)

    s1.delete(k3)
    let 1 = s1.len
    let 1 = s1.at(k1)


fn testUnordered()
    data u1 I64.Unordered

    let 0  = u1.len
    let k1 = u1.insert(1)
    let k2 = u1.insert(2)
    let k3 = u1.insert(3)

    let 3 = u1.len
    let 1 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 3 = u1.atIndex(2)
    let 1 = u1.at(k1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)

    u1.delete(k1)

    let 2 = u1.len
    let 3 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)


fn testSumType()
    let s : Sum{I64, Bool}
    let x = 0
    switch s
        I64(n); x = 1
        Bool(b); x = 2
    let 1 = x

//    let s2 = Sum{I64, Bool}(1)
//    switch s2
//        Bool(_);         let true = false
//        I64(n) | n != 1; let true = false
//        I64(1);          let true = true
//
//    fn i64(s &Sum{I64, Bool}) I64; return 0

//    s2 = conv(true)
//
//    if s2 -> Bool(true)
//        let true = true
//    else
//        let false = true


fn testMaybe()
    let m : I64.Maybe
    switch m
        Nothing(); let true = true
        I64(n) ; let false = true
    let false = m.isJust()

    m = I64.Maybe(3)
    switch m
        Nothing(); let false = true
        I64(3) ; let true = true
    let true = m.isJust()

    m.just() = 4
    let 4 = m.just
    let false = m.isNone

fn testTree()
    data t binaryTree::Tree{I64, Bool}
    let 0 = t.len()
    t.insert(1, true)
    t.insert(2, false)
    let 2 = t.Len::len()

    let true = t.at(1)
    let false = t.at(2)

    let true = t.contains(1)
    let true = t.contains(2)
    let false = t.contains(3)

    t.delete(1)
    let 1 = t.len

    let false = t.contains(1)
    let true = t.contains(2)
    let false = t.contains(3)

    t.insert(3, true)
    t.insert(1, true)

    let true = t.contains(1)
    let true = t.contains(2)
    let true = t.contains(3)


fn testMap()
    data m Map{I64, Bool}
    m.insert(1, true)
    m.insert(2, false)
    m.insert(3, true)

    let 3 = m.len

    let true = m[1]
    let false = m[2]

    let false = m.contains(0)


fn testSlice()
    data s Char.Table
    s.push("a string") 


fn testIo(io &Io)
    io.stdout.push("success", '\n', (1, true):(I64, Bool), " ")

    data table Tuple{I64, I64}.Table
    for (0, 10) -> i
        table.push((i * 2, i * 3))

    io.stdout.push(&table)


fn testArray()
    let array : I64.Array{4}
    builtin_array_at(&array, 2) = 78
    let 0 = builtin_array_at(&array, 1)
    let 78 = builtin_array_at(&array, 2)

    let 4 = array.len
    let 78 = array[2]


fn testArrayPattern()
    data t1 I64.Table
    t1.push(1, 2, 3)

    let [1, x, 3] = t1
    let 2 = x

    if t1 -> [1, 2]
        let true = false

    data t2 Char.Table
    t2.push("abc")

    let ['a', 'b', y] = t2
    let 'c' = y

    let ['a', 'b', 'c'] = "abc"
    let ['a', 'b', 'c'] = t2.slice(0, t2.len)


fn testArrayExpr()
    data t1 Tuple{I64, Bool}.Table
    t1 = [
        (1, true)
        (2, false)
        (3, true)
    ]

    let 1 = t1[0].0
    let false = t1[1].1

    t1 = [
        (4, false)
        (5, false)
    ]

    let 2 = t1.len
    let 5 = t1[1].0



fn testBoolConditions()
    let bool = true
    if bool
        let true = true
    else
        let false = true

    type AlwaysTrue Tuple{}

    let always : AlwaysTrue
    fn Construct::construct(a AlwaysTrue) Bool
        return true

    if always
        let true = true
    else
        let false = false

    type OnlyThrice I64
    fn Construct::construct(a I64) OnlyThrice
        let b : OnlyThrice
        ${ $b = $a; }
        return b

    fn Compare::equal(a OnlyThrice, b OnlyThrice) Bool
        let c : Bool
        ${ $c = $a == $b; }
        return c

    fn Store::store(a &OnlyThrice, b OnlyThrice)
        ${ *$a = $b; }

    fn Arithmetic::add(a OnlyThrice, b OnlyThrice) OnlyThrice
        let c : OnlyThrice
        ${ $c = $a + $b; }
        return c

    fn Construct::construct(a &OnlyThrice) Bool
        if a == 3
            return false
        else
            a = a + 1
            return true

    let count = 0
    let onlyThrice : OnlyThrice
    while &onlyThrice
        count = count + 1
    let 3 = count
        


fn testCharType()
    let a = 'c'
    let 'c' = a

    type MyChar Char.Tuple

    fn Store::store(a &MyChar, b MyChar); a.0 = b.0
    fn Construct::construct(a Char) MyChar
        let b : MyChar
        b.0 = a
        return b
    fn Compare::equal(a MyChar, b MyChar) Bool; return a.0 == b.0

    let m : MyChar = 'm'
    let 'm':MyChar = m
    if m -> 'n'
        let true = false


fn main()
    testArithmetic()
    testConvert()
    testFloats()
    testIf()
    testSwitch()
    testTuple()
    testLet()
    testFnWithRef()
    testTable()
    testSparse()
    testUnordered()
    testSumType()
    testMaybe()
    testTree()
    testMap()
    testSlice()
    testArray()
    testArrayPattern()
    testArrayExpr()
    testBoolConditions()
    testCharType()

    data io Io
    testIo(&io)


