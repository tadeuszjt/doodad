module langTest

import std/table
import std/sparse
import std/unordered
import std/maybe


fn testArithmetic()
    let x = 1 + 2
    let 3 = x

fn testFloats()
    let x = 1.0 + 2.0
    let 3.0 = x
    let 4.0 = 16.0 / 4.0

fn testIf()
    let x = 3
    if x == 3
        let true = true
    else
        let false = true


fn testSwitch()
    let x = 0
    switch 10
        x | x == 0; let true = false
        y | y == 10; x = 1
        _; let true = false

    let 1 = x


fn testLet()
    let x = 1 in
        x = 2
    let x = 4


fn testTuple()
    let x = (1, true)
    let (1, true) = x
    if x -> (1, false)
        let true = false


fn testGeneric()
    fn[T] add(a T, b T) T
        return a + b

    let 2 = add(1, 1)
    let 2.0 = add(1.0, 1.0)
    let (3, 4) = add( (1, 2), (2, 2) )


fn testTupleFields()
//    type MyTuple (a I64, b Bool)
//    let x : MyTuple = (1, true)
//    let 1 = x.a
//    let true = x.b
//
//    type[T] MyTuple2 (a Bool, b T)
//    let y : MyTuple2[F64]
//    y.b = 2.4
//    let (false, z) | z == 2.4 = y
    return


fn testFnWithRef()
    fn f(a &I64)
        a = a + 1
    let x = 1
    f(&x)
    let 2 = x

    fn g(a &I64) &I64
        a = a + 1
        return &a
    let y = 34
    g(&y)
    let 35 = y
    g(&y) = 0
    let 0 = y

    fn h(a &(I64, I64))
        a = (1, 2)
    let z = (0, 0)
    h(&z)
    let (1, 2) = z


fn testTable()
    data table Table[I64]

    let 0 = table.len
    table.push(1)
    table.push(2)
    table.push(3)

    let 3 = table.len
    let 1 = table.at(0)

    let 2 = table.at(1)
    builtin_table_at(&table, 1) = 3
    let 3 = builtin_table_at(&table, 1)

    let 3 = table.pop
    let 3 = table.pop
    let 1 = table.pop
    let 0 = table.len

    type Person (age I64, male Bool)
    data t2 Table[Person]

    t2.push( (1, true) : Person )
    t2.push( (2, false))

    let 2 = t2.len

    t2.at(1) = (3, true)
    let (3, true) = t2.pop


fn testSparse()
    data s1 Sparse[I64]

    let 0 = s1.len
    let k1 = s1.insert
    let k2 = s1.insert
    let k3 = s1.insert
    let 3 = s1.len

    s1.at(k1) = 1
    s1.at(k2) = 2
    s1.at(k3) = 3

    let 1 = s1.at(k1)
    let 2 = s1.at(k2)
    let 3 = s1.at(k3)

    s1.delete(k2)
    let 2 = s1.len
    let 1 = s1.at(k1)
    let 3 = s1.at(k3)

    s1.delete(k3)
    let 1 = s1.len
    let 1 = s1.at(k1)


fn testUnordered()
    data u1 Unordered[I64]

    let 0  = u1.len
    let k1 = u1.insert(1)
    let k2 = u1.insert(2)
    let k3 = u1.insert(3)

    let 3 = u1.len
    let 1 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 3 = u1.atIndex(2)
    let 1 = u1.at(k1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)

    u1.delete(k1)

    let 2 = u1.len
    let 3 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)


fn testMaybe()
    //let ma = Just(1)
    return


fn main()
    testArithmetic()
    testFloats()
    testIf()
    testSwitch()
    testTuple()
    testGeneric()
    testTupleFields()
    testLet()
    testFnWithRef()
    testTable()
    testSparse()
    testUnordered()
    testMaybe()

    print("success")
