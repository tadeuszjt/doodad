module langTest

import std/builtin
//import std/table
//import std/sparse
//import std/unordered
//import std/maybe
//import std/binaryTree
//import std/map
//import std/io
//import std/array
//import std/tuple
//import std/integer
//import std/floating
//import std/char
//import std/sum
//import std/slice
//import std/push
//import std/bool
//import std/features

feature{T}       store(T, T)
feature{T, A, B} construct2(A, B) T
feature{T, A, B, C} construct3(A, B, C) T

feature{T} add(T, T) T
feature{T} subtract(T, T) T
feature{T} divide(T, T) T
feature{T} equal(T, T) Bool


feature{T, G} first(T) G
feature{T, G} second(T) G
feature{T, G} third(T) G


feature{T}       len(T) I64
feature{T, K, V} at(T{V}, K) V
feature{T, V}    push(T{V}, V)
feature{T}       grow(T)
feature{T, V}    pop(T{V}) V


aquires store{I64}    (a&, b); builtinStore(&a, b)
aquires add{I64}      (a, b); return builtinAdd(a, b)
aquires subtract{I64} (a, b); return builtinSubtract(a, b)
aquires equal{ I64 }  (a, b); return builtinEqual(a, b)


aquires store{ F64 }  (a&, b); builtinStore(&a, b)
aquires add{ F64 }    (a, b); return builtinAdd(a, b)
aquires divide{ F64 } (a, b); return builtinDivide(a, b)
aquires equal{ F64 }  (a, b); return builtinEqual(a, b)


aquires store{ Bool } (a&, b); builtinStore(&a, b)
aquires equal{ Bool } (a, b); return builtinEqual(a, b)


aquires{A, B} store{ Tuple{A, B} } (a&, b)
    a.0 = b.0
    a.1 = b.1

aquires{A, B} construct2{ Tuple{A, B}, A, B } (x, y)
    let r
    r.0 = x
    r.1 = y
    return r

aquires{A, B} first{ Tuple{A, B}, A } (t&) -> &; return &t.0
aquires{A, B} second{ Tuple{A, B}, B } (t&) -> &; return &t.1


aquires{A, B, C} construct3{ Tuple{A, B, C}, A, B, C } (x, y, z)
    let r
    r.0 = x
    r.1 = y
    r.2 = z
    return r

aquires{A, B, C} first{ Tuple{A, B, C}, A } (t&) -> &; return &t.0
aquires{A, B, C} second{ Tuple{A, B, C}, B } (t&) -> &; return &t.1
aquires{A, B, C} third{ Tuple{A, B, C}, C } (t&) -> &; return &t.2

aquires{A, B, C} add{ Tuple{A, B, C} } (a, b); return (a.0 + b.0, a.1 + b.1, a.2 + b.2)


aquires{T} len{ T.Table }      (t&);           return builtinTableLen(&t)
aquires{T} at{ Table, I64, T } (t&, idx) -> &; return builtinTableAt(&t, idx)

aquires{T} push{ Table, T } (t&, e)
    builtinTableAppend(&t)
    builtinTableAt(&t, t.len - 1) = e

aquires{T} grow{ T.Table } (t&)
    builtinTableAppend(&t)

aquires{T} pop{ Table, T } (t&)
    let e = t.at(t.len - 1)
    ${ $t->len--; }
    return e


fn assert(cnd Bool)
    ${ if (!$cnd) { abort(); } }


fn testArithmetic()
    let x = 1 + 2
    let 3 = x
    return

fn testFloats()
    let x = 1.0 + 2.0
    let 3.0 = x
    let 4.0 = 16.0 / 4.0


fn testIf()
    let x = 3
    if x == 3
        let true = true
    else
        let false = true


fn testSwitch()
    let x = 0
    switch 10
        x | x == 0; let true = false
        y | y == 10; x = 1
        _; let true = false

    let 1 = x



//fn testConvert()
//    let 3 = 1 + 2
//    type MyInt I64
//
//    fn Store::store(a &MyInt, b MyInt)
//        Store::store(
//            &pretend(&a):I64
//            pretend(&b):I64
//        )
//
//    fn Arithmetic::add(a MyInt, b MyInt) MyInt; return builtin::add(a, b)
//    fn Compare::equal(a MyInt, b MyInt) Bool; return builtin::equal(a, b)
//
//    fn Construct::construct(a I64) MyInt
//        let b : MyInt
//        ${ $a = $b; }
//        return b
//
//    let 1 : MyInt = Arithmetic::add(0, 1)
//
//    let x : MyInt = 3
//    let 4 : MyInt = 1 + x
//    
//    let f = 3.14
//    let 3 = I64(f)
//    return
//
//

//fn testLet()
//    let x = 1 in
//        x = 2
//    let x = 4
//

fn testTuple()
    let x = (1, true)
    let (1, true) = x
    if x -> (1, false)
        let true = false
    let (3, 4, 5) = (1, 2, 3) + (2, 2, 2)


fn testFnWithRef()
    return // TODO
//    fn f(a &I64)
//        a = a + 1
//    let x = 1
//    f(&x)
//    let 2 = x
//
//    fn g(a &I64) &I64
//        a = a + 1
//        return &a
//    let y = 34
//    g(&y)
//    let 35 = y
//    g(&y) = 0
//    let 0 = y
//
//    fn h(a &(I64, I64))
//        a = (1, 2)
//    let z = (0, 0)
//    h(&z)
//    let (1, 2) = z


fn testTable()
    data table I64.Table

    let 0 = table.len
    table.push(1)
    table.push(2)
    table.push(3)

    let 3 = table.len
    let 1 = table.at(0)

    let 2 = table.at(1)
    builtin::builtinTableAt(&table, 1) = 3
    let 3 = builtin::builtinTableAt(&table, 1)

    let 3 = table.pop
    let 3 = table.pop
    let 1 = table.pop
    let 0 = table.len

    type Person (I64, Bool)
    aquires store{ Person } (a&, b)
        a.0 = b.0
        a.1 = b.1

    aquires first{ Person, I64 } (p&) -> &; return &p.0
    aquires second{ Person, Bool } (p&) -> &; return &p.1

    aquires construct2{ Person, I64, Bool } (a, b)
        let p : Person
        p.first = a
        p.second = b
        return p

    data t2 Person.Table

    t2.push( (1, true) )
    t2.push( (2, false) : Person )

    let 2 = t2.len

    t2.at(1) = (3, true)
    let (3, true) = t2.pop

    data m3 I64.Table.Table
    let 0 = m3.len
    m3.grow
    m3[0].grow
    let 1 = m3[0].len


//fn testSparse()
//    data s1 I64.Sparse
//
//    let 0 = s1.len
//    let k1 = s1.insert
//    let k2 = s1.insert
//    let k3 = s1.insert
//    let 3 = s1.len
//
//    s1.at(k1) = 1
//    s1.at(k2) = 2
//    s1.at(k3) = 3
//
//    let 1 = s1.at(k1)
//    let 2 = s1.at(k2)
//    let 3 = s1.at(k3)
//
//    s1.delete(k2)
//    let 2 = s1.len
//    let 1 = s1.at(k1)
//    let 3 = s1.at(k3)
//
//    s1.delete(k3)
//    let 1 = s1.len
//    let 1 = s1.at(k1)
//
//
//fn testUnordered()
//    data u1 I64.Unordered
//
//    let 0  = u1.len
//    let k1 = u1.insert(1)
//    let k2 = u1.insert(2)
//    let k3 = u1.insert(3)
//
//    let 3 = u1.len
//    let 1 = u1.atIndex(0)
//    let 2 = u1.atIndex(1)
//    let 3 = u1.atIndex(2)
//    let 1 = u1.at(k1)
//    let 2 = u1.at(k2)
//    let 3 = u1.at(k3)
//
//    u1.delete(k1)
//
//    let 2 = u1.len
//    let 3 = u1.atIndex(0)
//    let 2 = u1.atIndex(1)
//    let 2 = u1.at(k2)
//    let 3 = u1.at(k3)
//
//
//fn testSumType()
//    let s : Sum{I64, Bool}
//    let x = 0
////    switch s
////        I64(n); x = 1
////        Bool(b); x = 2
////    let 1 = x
//
////    let s2 = Sum{I64, Bool}(1)
////    switch s2
////        Bool(_);         let true = false
////        I64(n) | n != 1; let true = false
////        I64(1);          let true = true
////
////    fn i64(s &Sum{I64, Bool}) I64; return 0
//
////    s2 = conv(true)
////
////    if s2 -> Bool(true)
////        let true = true
////    else
////        let false = true
//
//
//fn testMaybe()
//    let m : I64.Maybe
//    switch m
//        nothing(); let true = true
//        just(); let false = true
//    let false = m.isJust()
//
//    m = just(3)
//    switch m
//        x | x.isNothing(); let false = true
//        just(3); let true = true
//
//    let true = m.isJust()
//
//    m.fromJust = 4
//    let 4 = m.fromJust
//    let false = m.isNothing
//
//fn testTree()
//    data t binaryTree::Tree{I64, Bool}
//    let 0 = t.len()
//    t.insert(1, true)
//    t.insert(2, false)
//    let 2 = t.Len::len()
//
//    let true = t.at(1)
//    let false = t.at(2)
//
//    let true = t.contains(1)
//    let true = t.contains(2)
//    let false = t.contains(3)
//
//    t.delete(1)
//    let 1 = t.len
//
//    let false = t.contains(1)
//    let true = t.contains(2)
//    let false = t.contains(3)
//
//    t.insert(3, true)
//    t.insert(1, true)
//
//    let true = t.contains(1)
//    let true = t.contains(2)
//    let true = t.contains(3)
//
//
//fn testMap()
//    data m Map{I64, Bool}
//    m.insert(1, true)
//    m.insert(2, false)
//    m.insert(3, true)
//
//    let 3 = m.len
//
//    let true = m[1]
//    let false = m[2]
//
//    let false = m.contains(0)
//
//
//fn testSlice()
//    data s Char.Table
//    s.push("a string") 
//
//
//fn testIo(io &Io)
//    io.stdout.push("success", '\n', (1, true):(I64, Bool), " ")
//
//    data table Tuple{I64, I64}.Table
//
//    for (0, 10) -> i
//        table.push((i * 2, i * 3))
//
//    io.stdout.push(&table)
//    return
//
//
//fn testArray()
//    let array : I64.Array{4}
//    builtin::arrayAt(&array, 2) = 78
//    let 0 = builtin::arrayAt(&array, 1)
//    let 78 = builtin::arrayAt(&array, 2)
//
//    let 4 = array.len
//    let 78 = array[2]
//
//
//fn testArrayPattern()
//    data t1 I64.Table
//    t1.push(1, 2, 3)
//
//    let [1, x, 3] = t1
//    let 2 = x
//
//    if t1 -> [_, _]
//        let true = false
//
//    data t2 Char.Table
//    t2.push("abc")
//
//    let ['a', 'b', y] = t2
//    let 'c' = y
//
//    let ['a', 'b', 'c'] = "abc"
//    let ['a', 'b', 'c'] = t2.slice(0, t2.len)
//
//
//fn testArrayExpr()
//    data t1 Tuple{I64, Bool}.Table
//    t1 = [
//        (1, true)
//        (2, false)
//        (3, true)
//    ]
//
//    let 1 = t1[0].0
//    let false = t1[1].1
//
//    t1 = [
//        (4, false)
//        (5, false)
//    ]
//
//    let 2 = t1.len
//    let 5 = t1[1].0
//
//
//
//fn testBoolConditions()
//    let bool = true
//    if bool
//        let true = true
//    else
//        let false = true
//
//    type AlwaysTrue Tuple{}
//
//    let always : AlwaysTrue
//    fn Construct::construct(a AlwaysTrue) Bool
//        return true
//
//    if always
//        let true = true
//    else
//        let false = false
//
//    type OnlyThrice I64
//    fn Construct::construct(a I64) OnlyThrice
//        let b : OnlyThrice
//        ${ $b = $a; }
//        return b
//
//    fn Compare::equal(a OnlyThrice, b OnlyThrice) Bool
//        let c : Bool
//        ${ $c = $a == $b; }
//        return c
//
//    fn Store::store(a &OnlyThrice, b OnlyThrice)
//        ${ *$a = $b; }
//
//    fn Arithmetic::add(a OnlyThrice, b OnlyThrice) OnlyThrice
//        let c : OnlyThrice
//        ${ $c = $a + $b; }
//        return c
//
//    fn Construct::construct(a &OnlyThrice) Bool
//        if a == 3
//            return false
//        else
//            a = a + 1
//            return true
//
//    let count = 0
//    let onlyThrice : OnlyThrice
//    while &onlyThrice
//        count = count + 1
//    let 3 = count
//        
//
//
//fn testCharType()
//    let a = 'c'
//    let 'c' = a
//
//    type MyChar Char.Tuple
//
//    fn Store::store(a &MyChar, b MyChar); a.0 = b.0
//    fn Construct::construct(a Char) MyChar
//        let b : MyChar
//        b.0 = a
//        return b
//    fn Compare::equal(a MyChar, b MyChar) Bool; return a.0 == b.0
//
//    let m : MyChar = 'm'
//    let 'm':MyChar = m
//    if m -> 'n'
//        let true = false
//
//
//fn testEnum()
//    enum Enum {
//        one
//        two
//        three
//    }
//
//    let e : Enum
//
//    switch e
//        _ | e.isOne; let true = true
//        _ | e.isTwo; let false = true
//
//    e.builtin::sumReset(1)
//
//    switch e
//        _ | e.isOne; let true = false
//        _ | e.isTwo; let true = true
//
//    let true = Enum::three().isThree()
//
//    enum Enum2 {
//        one(I64)
//        two(I64, I64)
//    }
//
//    let true = Enum2::two(1, 2).isTwo
//    let false = Enum2::two(1, 2).isOne
//    let 1 = Enum2::two(1, 2). 1 . 0
//
//
//fn testMacroTuple()
//    tuple{T} MyTuple {
//        one I64
//        two T
//    }
//
//    let t : Bool.MyTuple
//    t.one = 23
//
//    let 23 = t.one
//
//    let false = t.two
//    t.MyTuple::two = true
//    let true = t.two
//
//fn testBuiltin()
//    let x : I64
//    let y : I64 = x.pretend()
//    return


fn main()
    testArithmetic()
    testFloats()
    testIf()
    testSwitch()
//    testConvert()
    testTuple()
//    testLet()
    testFnWithRef()
    testTable()
//    testSparse()
//    testUnordered()
//    testSumType()
//    testMaybe()
//    testTree()
//    testMap()
//    testSlice()
//    testArray()
//    testArrayPattern()
//    testArrayExpr()
//    testBoolConditions()
//    testCharType()
//    testEnum()
//    testMacroTuple()
//    testBuiltin()
//
//    data io Io
//    testIo(&io)
    ${ puts("langTest success"); }
    return
