module langTest

import std/table
import std/sparse
import std/unordered
import std/maybe
import std/binaryTree
import std/map
import std/io


fn testArithmetic()
    let x = 1 + 2
    let 3 = x

fn testFloats()
    let x = 1.0 + 2.0
    let 3.0 = x
    let 4.0 = 16.0 / 4.0

fn testIf()
    let x = 3
    if x == 3
        let true = true
    else
        let false = true


fn testSwitch()
    let x = 0
    switch 10
        x | x == 0; let true = false
        y | y == 10; x = 1
        _; let true = false

    let 1 = x


fn testLet()
    let x = 1 in
        x = 2
    let x = 4


fn testTuple()
    let x = (1, true)
    let (1, true) = x
    if x -> (1, false)
        let true = false


fn testGeneric()
    fn{T} add(a T, b T) T
        return a + b

    let 2 = add(1, 1)
    let 2.0 = add(1.0, 1.0)
    let (3, 4) = add( (1, 2), (2, 2) )


fn testFnWithRef()
    fn f(a &I64)
        a = a + 1
    let x = 1
    f(&x)
    let 2 = x

    fn g(a &I64) &I64
        a = a + 1
        return &a
    let y = 34
    g(&y)
    let 35 = y
    g(&y) = 0
    let 0 = y

    fn h(a &(I64, I64))
        a = (1, 2)
    let z = (0, 0)
    h(&z)
    let (1, 2) = z


fn testTable()
    data table I64.Table

    let 0 = table.len
    table.push(1)
    table.push(2)
    table.push(3)

    let 3 = table.len
    let 1 = table.at(0)

    let 2 = table.at(1)
    builtin_table_at(&table, 1) = 3
    let 3 = builtin_table_at(&table, 1)

    let 3 = table.pop
    let 3 = table.pop
    let 1 = table.pop
    let 0 = table.len

    type Person (I64, Bool)
    data t2 Person.Table

    t2.push( (1, true) )
    t2.push( (2, false))

    let 2 = t2.len

    t2.at(1) = (3, true)
    let (3, true) = t2.pop

    data m3 I64.Table.Table
    let 0 = m3.len
    m3.push
    m3[0].push
    let 1 = m3[0].len


fn testSparse()
    data s1 I64.Sparse

    let 0 = s1.len
    let k1 = s1.insert
    let k2 = s1.insert
    let k3 = s1.insert
    let 3 = s1.len

    s1.at(k1) = 1
    s1.at(k2) = 2
    s1.at(k3) = 3

    let 1 = s1.at(k1)
    let 2 = s1.at(k2)
    let 3 = s1.at(k3)

    s1.delete(k2)
    let 2 = s1.len
    let 1 = s1.at(k1)
    let 3 = s1.at(k3)

    s1.delete(k3)
    let 1 = s1.len
    let 1 = s1.at(k1)


fn testUnordered()
    data u1 I64.Unordered

    let 0  = u1.len
    let k1 = u1.insert(1)
    let k2 = u1.insert(2)
    let k3 = u1.insert(3)

    let 3 = u1.len
    let 1 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 3 = u1.atIndex(2)
    let 1 = u1.at(k1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)

    u1.delete(k1)

    let 2 = u1.len
    let 3 = u1.atIndex(0)
    let 2 = u1.atIndex(1)
    let 2 = u1.at(k2)
    let 3 = u1.at(k3)


fn testSumType()
    let s : Sum{I64, Bool}
    let x = 0
    switch s
        I64(n); x = 1
        Bool(b); x = 2
    let 1 = x

    let s2 = Sum{I64, Bool}(1)
    switch s2
        Bool(_);         let true = false
        I64(n) | n != 1; let true = false
        I64(1);          let true = true

    s2 = conv(true)

    if s2 -> Bool(true)
        let true = true
    else
        let false = true


fn testMaybe()
    let m : I64.Maybe
    switch m
        Nothing(); let true = true
        I64(n) ; let false = true
    let false = m.hasValue()

    m = Maybe{I64}(3)
    switch m
        Nothing(); let false = true
        I64(3) ; let true = true
    let true = m.hasValue()


fn testTree()
    data t binaryTree::Tree{I64, Bool}
    let 0 = t.len()
    t.insert(1, true)
    t.insert(2, false)
    let 2 = t.len()

    let true = t.at(1)
    let false = t.at(2)

    let true = t.contains(1)
    let true = t.contains(2)
    let false = t.contains(3)

    t.delete(1)
    let 1 = t.len

    let false = t.contains(1)
    let true = t.contains(2)
    let false = t.contains(3)

    t.insert(3, true)
    t.insert(1, true)

    let true = t.contains(1)
    let true = t.contains(2)
    let true = t.contains(3)


fn testMap()
    data m Map{I64, Bool}
    m.insert(1, true)
    m.insert(2, false)
    m.insert(3, true)

    let 3 = m.len

    let true = m[1]
    let false = m[2]

    let false = m.contains(0)


fn testIo()
    data io Io
    io.putChar('b')

    data string Char.Table

    string.push('b')
    string.push('e')
    string.push('n')
    string.push('i')

    let 4 = string.len

    io.putStrLn(&string)


fn testSlice()
    data t I64.Table
    
    t.push(1)
    t.push(2)
    t.push(3)

    print(builtin_table_slice(&t))


fn main()
    testArithmetic()
    testFloats()
    testIf()
    testSwitch()
    testTuple()
    testGeneric()
    testLet()
    testFnWithRef()
    testTable()
    testSparse()
    testUnordered()
    testSumType()
    testMaybe()
    testTree()
    testMap()
    testIo()
    testSlice()

    print("success")
