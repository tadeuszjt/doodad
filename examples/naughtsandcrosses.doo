module naughtsandcrossesOld

import ../std/io
import ../std/strings
import ../std/rand


type Square { Empty() | Naught() | Cross() }
type Board  [3 [3 Square]]


fn {board Board, io Io} printBoard()
    for board -> row
        io.write('[')
        for row[..] -> r
            switch row[r]
                Empty();  io.write(' ')
                Naught(); io.write('0')
                Cross();  io.write('X')
            if r < (row.len() - 1); io.write(',')
        {io, "]"}.writeLn()


fn {board Board} winner() Square
    for board -> row
        let same = true
        for row -> sq
            same = same && sq == row[0]
        if same && row[0] != Empty(); return row[0]

    for board[0][..] -> c
        let same = true
        for board[..] -> r
            same = same && board[r][c] == board[0][c]
        if same && board[0][c] != Empty(); return board[0][c]

    if board[0][0] != Empty()
        let same = true
        for board[..] -> r
            same = same && board[r][r] == board[0][0]
        if same; return board[0][0]
        
    if true
        let same = true
        let end = board[0].len() - 1
        for board[..] -> r
            same = same && board[r][end - r] == board[0][end]
        if same && board[end][0] != Empty(); return board[end][0]

    return Empty()


fn {board Board} full() bool
    for board -> row
        for row -> sq
            if sq == Empty()
                return false
    return true


type playerMoveReturn { Error() | Success() | Quit() }
fn {board Board, io Io} playerMove() playerMoveReturn
    {io, "Make a move"}.writeLn()

    data line string
    {io, line}.readLn()
    if line.read(0) -> ('q', _:i64)
        return Quit()

    let (row:i64, n) = line.read(0)
    let (col:i64, n2) = line.read(n)

    let noParse = n == 0 || n2 == 0
    if noParse || !board[..][row] || !board[row][..][col]
        {io, "invalid move"}.writeLn()
        return Error()

    if board[row][col] != Empty()
        {io, "board[row][col] is not empty"}.writeLn()
        return Error()

    board[row][col] = Naught()
    return Success()


fn {io Io, board Board, rand Rand} cpuMove()
    {io, "cpu moving"}.writeLn()
    if board.full()
        return

    data empty [(i64, i64)]
    for board[..] -> r
        for board[r][..] -> c
            if board[r][c] == Empty()
                empty.push((r, c))

    for empty -> (r, c)
        board[r][c] = Cross()
        if board.winner() == Cross()
            return
        board[r][c] = Empty()

    for empty -> (r, c)
        board[r][c] = Naught()
        if board.winner() == Naught()
            board[r][c] = Cross()
            return
        board[r][c] = Empty()

    let (r, c) = empty[rand.I64() % empty.len()]
    board[r][c] = Cross()
    return


fn {board Board, io Io} playerMoveLoop() playerMoveReturn
    switch {board, io}.playerMove()
        Quit();    return Quit()
        Success(); return Success()
        Error();   return {board, io}.playerMoveLoop()


fn {io Io} main()
    data board Board
    data rand Rand

    while !board.full() && board.winner() == Empty()
        switch {board, io}.playerMoveLoop()
            Quit()   ; return
            Success();

        {board, io}.printBoard()
        {io, board, rand}.cpuMove()
        {board, io}.printBoard()


