module container

import builtin/builtin
import builtin/store
import builtin/arithmetic
import builtin/assert
import builtin/convert


feature{T}                 len(T) I64
feature{T, V | T -> V}     push(T, V)
feature{T, V | T -> V}     pop(T) V
feature{K, V, T | T->V, T->K } at(T, K) V
feature{T}                 grow(T)
feature{T, V | T -> V}     index(T, I64) V


acquires{V} len{ Table{V} }        (t&);           return t.builtinTableLen()
acquires{T} index{ Table{T}, T }   (t&, idx) -> &; return t.builtinTableAt(idx)
acquires{T} at{ I64, T, Table{T} } (t&, idx) -> &; return t.builtinTableAt(idx)


acquires{T} push{ Table{T}, T } (t&, e)
    builtinTableAppend(&t)
    builtinTableAt(&t, t.len - 1) = e

acquires{T} grow{ T.Table } (t&)
    builtinTableAppend(&t)

acquires{T} pop{ Table{T}, T } (t&)
    let e = t.at(t.len - 1)
    t.at(t.len - 1).destroy
    ${ $t->len--; }
    return e


acquires{T} len{ T.Slice }         (s&);           return builtinSliceLen(&s)
acquires{T} index{ Slice{T}, T}    (s&, idx) -> &; return builtinSliceAt(&s, idx)
acquires{T} at{ I64, T, Slice{T} } (s&, idx) -> &; return builtinSliceAt(&s, idx)


acquires{T, S} at{ I64, T, Array{S, T} } (arr&, idx) -> &; return builtinArrayAt(&arr, idx)
acquires{T, S} len{ Array{S, T} }        (arr&);           return builtinArrayLen(&arr)
