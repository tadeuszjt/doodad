module destroy

import builtin/tuple
import builtin/convert
import builtin/container
import builtin/builtin
import builtin/for
import builtin/store
import builtin/compare


//feature{T} destroy(T)

acquires destroy{ U8 } (n&); return
//acquires destroy{ I64 } (n&); return
//acquires destroy{ F32 } (n&); return
//acquires destroy{ F64 } (n&); return


acquires{T} destroy{ Slice{T} } (slice&); return


acquires{A} destroy{ Tuple{A} } (tup&)
    tup.0 .destroy

acquires{A, B} destroy{ Tuple{A, B} } (tup&)
    tup.0 .destroy
    tup.1 .destroy

acquires{A, B, C} destroy{ Tuple{A, B, C} } (tup&)
    tup.0 .destroy
    tup.1 .destroy
    tup.2 .destroy

acquires{A, B, C, D} destroy{ Tuple{A, B, C, D} } (tup&)
    tup.0 .destroy
    tup.1 .destroy
    tup.2 .destroy
    tup.3 .destroy


acquires{N, T} destroy{ Array{N, T} } (arr&)
    for (0, arr.len) -> i
        arr[i].destroy
    

acquires{T} destroy{ T.Table } (t&)
    for (0, t.len) -> i
        t[i].destroy
    ${
        //printf("destroying table:%p\n", $t->r0);
        if ($t->r0) free($t->r0);
        $t->r0 = NULL;
        $t->len = 0;
        $t->cap = 0;
    }


acquires{A} destroy{Sum{A}} (sum&)
    sum.0 .destroy
    ${ memset($sum, 0, sizeof(*$sum)); }


acquires{A, B} destroy{Sum{A, B}} (sum&)
    switch sum.builtinSumEnum
        0; sum.0 .destroy
        1; sum.1 .destroy

    ${ memset($sum, 0, sizeof(*$sum)); }


acquires{A, B, C} destroy{ Sum{A, B, C} } (sum&)
    switch sum.builtinSumEnum
        0; sum.0 .destroy
        1; sum.1 .destroy
        2; sum.2 .destroy

    ${ memset($sum, 0, sizeof(*$sum)); }

