module unordered

import std/sparse
import std/container
import std/store
import std/assert
import std/tuple
import std/builtin
import std/arithmetic
import std/print
import std/for
import std/compare
import std/convert


type{T} Key I64
derives{T} Key{T} (store)


tuple{T} Unordered {
    indices I64.Sparse
    entries I64.Key.Table
    values  T.Table
}



acquires{T} len{ T.Unordered } (u&)
    return u.values.len


fn{T} insertZero(u &T.Unordered) T.Key
    let key = u.indices.sparse::insert(u.values.len)

    u.values.grow
    u.entries.grow
    u.entries[u.entries.len - 1] = key.pretend:Key{I64}

    return key.pretend


fn{T} insert(u &T.Unordered, elem T) T.Key
    let key = u.indices.sparse::insert(u.values.len)

    u.values.grow
    u.entries.grow
    u.values[u.values.len - 1] = elem
    u.entries[u.entries.len - 1] = key.pretend:Key{I64}

    return key.pretend


acquires{T} index{ Unordered, T } (u&, idx) -> &
    return u.values[idx]


acquires{T} at{ Unordered, T.Key, T} (u&, key) -> &
    let index = u.indices[key.pretend:sparse::Key{I64}]
    return &u.values[index]


fn{T} delete(u &T.Unordered, key T.Key)
    let end    = u.entries.len - 1
    let endKey = u.entries[end]
    let index  = u.indices.at(key.pretend:sparse::Key{I64})

    u.entries[index] = u.entries[end]
    u.values[index] = u.values[end]

    u.indices.at(endKey.pretend:sparse::Key{I64}) = index
    u.indices.sparse::delete(key.pretend)
    u.values.pop
    u.entries.pop


acquires{P, T} print{P, Unordered{T}} (p&, u&)
    p.print('[')

    for (0, u.len) -> idx
        p.print(u.index(idx))

        if idx < (u.len - 1)
            p.print(", ")

    p.print(']')
