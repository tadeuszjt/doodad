module unordered

import std/sparse
import std/table
import std/integer
import std/features

type{T} Key I64


tuple{T} Entry {
    key   I64.unordered::Key
    value T
}

tuple{T} Unordered {
    indices I64.Sparse
    values  T.Entry.Table
}

fn{T} Store::store(a &T.unordered::Key, b T.unordered::Key)
    Store::store(
        &builtin_pretend(&a):I64
        builtin_pretend(&b):I64
    )

fn{T} Store::store(a &T.Entry, b T.Entry)
    a.key = b.key
    a.value = b.value


fn{T} Construct::construct(a I64.unordered::Key, b T) T.Entry
    let e : T.Entry
    e.0 = a
    e.1 = b
    return e


fn{T} Construct::construct(n I64) T.unordered::Key
    return builtin_pretend(&n)

fn{A, B} Construct::construct(x A.unordered::Key) B.sparse::Key
    return x.builtin_pretend

fn{A, B} Construct::construct(x A.sparse::Key) B.unordered::Key
    return x.builtin_pretend


fn{T} Len::len(u &T.Unordered) I64
    return u.values.len


fn{T} insert(u &T.Unordered, elem T) T.unordered::Key
    let key = u.indices.insert(u.values.len)
    u.values.push( (key.builtin_pretend, elem) : T.Entry )
    return key.builtin_pretend


fn{T} insert(u &T.Unordered) T.unordered::Key
    let key = u.indices.insert(u.values.len)
    u.values.push()
    u.values[u.values.len - 1].key = I64.unordered::Key(key)
    return T.unordered::Key(key)


fn{T} At::at(u &T.Unordered, key T.unordered::Key) &T
    let index = u.indices.At::at(key.builtin_pretend)
    return &u.values.at(index).value


fn{T} atIndex(u &T.Unordered, index I64) &T
    return &u.values.at(index).value


fn{T} delete(u &T.Unordered, key T.unordered::Key)
    let end    = u.values.len - 1
    let endKey = u.values.at(end).key
    let index  = u.indices.at(I64.sparse::Key(key))

    u.values.at(index) = u.values.at(end)
    u.indices.at(endKey.builtin_pretend) = index
    u.indices.delete(key.builtin_pretend)
    u.values.pop
