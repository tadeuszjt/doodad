module unordered

import std/sparse
import std/table

type[T] Key I64
type[T] Entry ( Key[I64], T )
type[T] Unordered ( Sparse[I64], Table[Entry[T]] )


fn[T] key(e &Entry[T]) &Key[I64];               return &e.0
fn[T] value(e &Entry[T]) &T;                    return &e.1
fn[T] indices(u &Unordered[T]) &Sparse[I64];    return &u.0
fn[T] values(u &Unordered[T]) &Table[Entry[T]]; return &u.1


fn[T] len(u &Unordered[T]) I64
    return u.values.len

fn[T] insert(u &Unordered[T], elem T) Key[T]
    let key = u.indices.insert(u.values.len)
    u.values.push((conv(key), elem))
    return conv(key)

fn[T] insert(u &Unordered[T]) Key[T]
    let value : T
    return u.insert(value)


fn[T] at(u &Unordered[T], key Key[T]) &T
    let index = u.indices.at(conv(key))
    return &u.values.at(index).value


fn[T] atIndex(u &Unordered[T], index I64) &T
    return &u.values.at(index).value


fn[T] delete(u &Unordered[T], key Key[T])
    let end    = u.values.len - 1
    let endKey = u.values.at(end).key
    let index  = u.indices.at(conv(key))

    u.values.at(index) = u.values.at(end)
    u.indices.at(conv(endKey)) = index
    u.indices.delete(conv(key))
    u.values.pop
