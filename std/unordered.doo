module unordered

import std/sparse
import std/table


type[T] UnorderedKey i64
type[T] UnorderedRecord { key:UnorderedKey(i64), value:T }
type[T] Unordered ( indices:Sparse(i64), values:[]UnorderedRecord(T) )

fn[T] {u:Unordered(T)} insert(elem:()T) UnorderedKey(T)
    let index = u.values.length()
    let key   = u.indices.insert(index)
    u.values.push((conv(key), elem))
    return conv(key)

fn[T] {u:Unordered(T)} insert() UnorderedKey(T)
    let key = u.indices.insert(u.values.length())
    u.values++
    u.values[u.values.length() - 1].key = conv(key)
    return conv(key)


fn[T] {u:Unordered(T)} delete(key:UnorderedKey(T))
    let end    = u.values.length() - 1
    let endKey = u.values[end].key
    let index  = u.indices.get(conv(key))

    u.values[index]            = u.values[end]
    u.indices.at(conv(endKey)) = index{}
    u.indices.delete(conv(key))
    u.values.pop()


fn[T] {u:Unordered(T)} atIndex(index:i64) {}T
    return u.values[index].value{}


fn[T] {u:Unordered(T)} at(key:UnorderedKey(T)) {}T
    let {index} = u.indices.at(conv(key)) in
        return u.values[index].value


fn[T] {u:Unordered(T)} length() i64
    return u.values.length()
