module builtin


// memory
fn{T} builtinStore(a &T, b T); ${ assert(false); }

feature{T} destroy(T)
acquires destroy{Char} (c&); return
acquires destroy{Bool} (c&); return
acquires destroy{F32} (c&); return
acquires destroy{F64} (c&); return
acquires destroy{I64} (c&); return
acquires destroy{I32} (c&); return

acquires destroy{Tuple{}} (tup&); return

// types
fn{T, G} pretend(a &T) &G; ${ return $a; }


feature{N, G, T | N -> G} field(T) G

acquires{A, B} field{0, A, Tuple{A, B}} (tup&) -> &; return tup.builtinField{0, A, Tuple{A, B}}
acquires{A, B} field{1, B, Tuple{A, B}} (tup&) -> &; return tup.builtinField{1, B, Tuple{A, B}}

acquires{A, B, C} field{0, A, Tuple{A, B, C}} (tup&) -> &; return tup.builtinField{0, A, Tuple{A, B, C}}
acquires{A, B, C} field{1, B, Tuple{A, B, C}} (tup&) -> &; return tup.builtinField{1, B, Tuple{A, B, C}}
acquires{A, B, C} field{2, C, Tuple{A, B, C}} (tup&) -> &; return tup.builtinField{2, C, Tuple{A, B, C}}

acquires{A, B, C, D} field{0, A, Tuple{A, B, C, D}} (tup&) -> &; return tup.builtinField{0, A, Tuple{A, B, C, D}}
acquires{A, B, C, D} field{1, B, Tuple{A, B, C, D}} (tup&) -> &; return tup.builtinField{1, B, Tuple{A, B, C, D}}
acquires{A, B, C, D} field{2, C, Tuple{A, B, C, D}} (tup&) -> &; return tup.builtinField{2, C, Tuple{A, B, C, D}}
acquires{A, B, C, D} field{3, D, Tuple{A, B, C, D}} (tup&) -> &; return tup.builtinField{3, D, Tuple{A, B, C, D}}

acquires{A} field{0, A, Sum{A}} (sum&) -> &; return sum.builtinField{0, A, Sum{A}}

acquires{A, B} field{0, A, Sum{A, B}} (sum&) -> &; return sum.builtinField{0, A, Sum{A, B}}
acquires{A, B} field{1, B, Sum{A, B}} (sum&) -> &; return sum.builtinField{1, B, Sum{A, B}}

acquires{A, B, C} field{0, A, Sum{A, B, C}} (sum&) -> &; return sum.builtinField{0, A, Sum{A, B, C}}
acquires{A, B, C} field{1, B, Sum{A, B, C}} (sum&) -> &; return sum.builtinField{1, B, Sum{A, B, C}}
acquires{A, B, C} field{2, C, Sum{A, B, C}} (sum&) -> &; return sum.builtinField{2, C, Sum{A, B, C}}


fn{I, G, T} builtinField(t &T) &G; ${ assert(false); }
fn{T, G} builtinConvert(a T) G;    ${ assert(false); }


// arithmetic
fn{T} builtinAdd(a T, b T) T;      ${ assert(false); }
fn{T} builtinSubtract(a T, b T) T; ${ assert(false); }
fn{T} builtinMultiply(a T, b T) T; ${ assert(false); }
fn{T} builtinDivide(a T, b T) T;   ${ assert(false); }
fn{T} builtinModulo(a T, b T) T;   ${ assert(false); }


// boolean
fn{T} builtinEqual(a T, b T)       Bool; ${ assert(false); }
fn{T} builtinLessThan(a T, b T)    Bool; ${ assert(false); }
fn{T} builtinGreaterThan(a T, b T) Bool; ${ assert(false); }

fn{T} builtinAnd(a T, b T) T; ${ assert(false); }
fn{T} builtinOr(a T, b T)  T; ${ assert(false); }
fn{T} builtinNot(a T)      T; ${ assert(false); }


// container
fn{T} builtinTableLen(a &T.Table) I64;      ${ assert(false); }
fn{T} builtinTableAppend(a &T.Table);       ${ assert(false); }
fn{T} builtinTableAt(a &T.Table, b I64) &T; ${ assert(false); }

fn{T, S} builtinArrayLen(a &Array{S, T}) I64;        ${ assert(false); }
fn{T, S} builtinArrayAt(a &Array{S, T}, idx I64) &T; ${ assert(false); }

fn{T} builtinSliceLen(a &T.Slice) I64;      ${ return $a->len; }
fn{T} builtinSliceAt(a  T.Slice, b I64) &T; ${ assert(false); }


// sum
fn{T} builtinSumEnum(t &T) I64;      ${ return $t->en; }
fn{T} builtinSumReset(t &T, en I64); ${ assert(false); }
