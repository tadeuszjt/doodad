module builtin

// memory
fn{T} builtinStore(a &T, b T); ${ *$a = $b; }

feature{T} destroy(T)
acquires destroy{Char} (c&); return
acquires destroy{Bool} (c&); return
acquires destroy{F32} (c&); return
acquires destroy{F64} (c&); return
acquires destroy{I64} (c&); return
acquires destroy{I32} (c&); return

acquires{A, B} destroy{Sum{A, B}} (sum&); return // TODO
acquires{A} destroy{Sum{A}} (sum&); return // TODO

acquires destroy{Tuple{}} (tup&); return

// types
fn{T, G} pretend(a &T) &G; ${ return $a; }


// arithmetic
fn{T} builtinAdd(a T, b T) T; ${ return $a + $b; }

fn{T} builtinSubtract(a T, b T) T; ${ return $a - $b; }
fn{T} builtinMultiply(a T, b T) T; ${ return $a * $b; }
fn{T} builtinDivide(a T, b T) T; ${ return $a / $b; }
fn{T} builtinModulo(a T, b T) T; ${ return $a % $b; }


// boolean
fn{T} builtinEqual(a T, b T)       Bool; ${ return $a == $b; }
fn{T} builtinLessThan(a T, b T)    Bool; ${ return $a < $b; }
fn{T} builtinGreaterThan(a T, b T) Bool; ${ return $a > $b; }

fn{T} builtinAnd(a T, b T) T; ${ return $a && $b; }
fn{T} builtinOr(a T, b T)  T; ${ return $a || $b; }
fn{T} builtinNot(a T)      T; ${ return !$a; }


// container
fn{T} builtinTableLen(a &T.Table) I64;      ${ assert(false); }
fn{T} builtinTableAppend(a &T.Table);       ${ assert(false); }
fn{T} builtinTableAt(a &T.Table, b I64) &T; ${ assert(false); }

fn{T, S} builtinArrayLen(a &Array{S, T}) I64;        ${ assert(false); }
fn{T, S} builtinArrayAt(a &Array{S, T}, idx I64) &T; ${ assert(false); }

fn{T} builtinSliceLen(a &T.Slice) I64;      ${ return $a->len; }
fn{T} builtinSliceAt(a  T.Slice, b I64) &T; ${ assert(false); }


// sum
fn{T} builtinSumEnum(t &T) I64;      ${ return $t->en; }
fn{T} builtinSumReset(t &T, en I64); ${ assert(false); }
