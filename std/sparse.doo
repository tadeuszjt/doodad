module sparse

import std/table
import std/bool
import std/integer

type{T} Key    I64

tuple{T} Sparse {
    values T.Table
    empty  T.Key.Table
}

fn{T} Store::store(a &T.Key, b T.Key)
    Store::store(
        &builtin_pretend(&a):I64
        builtin_pretend(&b):I64
    )

fn{T} Construct::construct(n I64) T.Key; return conv(n)
fn{T} Construct::construct(k T.Key) I64; return conv(k)

fn{T} Len::len(s &T.Sparse) I64
    return s.values.Len::len - s.empty.len


fn{T} At::at(s &T.Sparse, key T.Key) &T
    return s.values.at(I64(key))

fn{T} insert(s &T.Sparse) T.Key
    let value : T
    return s.insert(value)


fn{T} insert(s &T.Sparse, value T) T.Key
    if s.empty.len > 0
        let key = s.empty.pop
        s.values.at(I64(key)) = value
        return key

    s.values.push(value)
    return T.Key(s.values.len - 1)


fn{T} delete(s &T.Sparse, key T.Key)
    if I64(key) == (s.values.len - 1)
        s.values.pop
    else
        s.empty.push(key)
