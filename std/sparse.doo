module sparse

import std/table

type[T] Key    I64
type[T] Sparse (
    values Table[T]
    empty  Table[Key[T]]
)


fn[T] len(s &Sparse[T]) I64
    return s.values.len() - s.empty.len()


fn[T] at(s &Sparse[T], key Key[T]) &T
    return s.values.at(conv(key))

fn[T] insert(s &Sparse[T]) Key[T]
    let value : T
    return s.insert(value)


fn[T] insert(s &Sparse[T], value T) Key[T]
    if s.empty.len() > 0
        let key = s.empty.pop()
        s.values.at(conv(key)) = value
        return key

    s.values.push(value)
    return conv(s.values.len() - 1)


fn[T] delete(s &Sparse[T], key Key[T])
    if key == conv(s.values.len() - 1)
        s.values.pop()
    else
        s.empty.push(key)

//fn[T] {s Sparse[T]} insert(value ()T) Key[T]
//    if s.empty.len() > 0
//        let key = s.empty.pop()
//        s.values.at(conv(key)) = value{}
//        return key
//
//    s.values.push(value)
//    return conv(s.values.len() - 1)
//
//


//
//
//fn[T] {s Sparse[T]} replace(key Key[T], elem ()T)
//    s.values.at(conv(key)) = elem{}
