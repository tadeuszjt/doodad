module sparse

import std/builtin
import std/store
import std/arithmetic
import std/compare
import std/container
import std/assert

type{T} Key I64

tuple{T} Sparse {
    values T.Table
    empty  T.Key.Table
}

derives{T} Key{T} (store)


acquires{T} container::len{ T.Sparse } (s&)
    return s.values.len - s.empty.len

acquires{T, K, V} container::at{ Sparse, T.Key, V } (s&, key) -> &
    return s.values.at( key.pretend:I64 )


fn{T} insertZero(s &T.Sparse) T.Key
    let value : T
    return s.insert(value)


fn{T} insert(s &T.Sparse, value T) T.Key
    if s.empty.len > 0
        let key = s.empty.pop
        s.values.at( key.pretend:I64 ) = value
        return key

    s.values.push(value)
    return (s.values.len - 1).pretend


fn{T} delete(s &T.Sparse, key T.Key)
    if key.pretend:I64 == (s.values.len - 1)
        s.values.pop
    else
        s.empty.push(key)
