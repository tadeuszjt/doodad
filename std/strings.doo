module strings

fn isAlpha(c char) bool
    let r = false
    ${ $r = isalpha($c); }
    return r


fn isDigit(c char) bool
    let r = false
    ${ $r = isdigit($c); }
    return r


fn isSpace(c char) bool
    let r = false
    ${ $r = isspace($c); }
    return r


fn isPrefix(pre string, str string) bool
    if len(pre) > len(str); return false
    for pre[..] -> i
        if str[i] != pre[i]; return false
    return true


fn {s string} at(idx i64) {null | char}
    if idx >= 0 && idx < len(s)
        return conv(s[idx])
    return null


fn drop(s string, n i64) string
    let r = ""
    ${
        if ($n <= strlen($s)) {
            $r = $s + $n;
        }
    }
    return r


fn take(s string, n i64) string
    let r = ""
    ${
        size_t len = strlen($s);
        if ($n >= len) {
            $r = $s;
        } else {
            $r = doodad_string_alloc($n);
            memcpy($r, $s, $n);
            $r[$n] = '\0';
        }
    }
    return r


fn readI64(s string) ({null | i64}, string)
    let fail = (null, s)

    while s.at(0) -> *char(c) | isSpace(c)
        s = drop(s, 1)

    let isMinus = false
    if s.at(0) -> *char('-')
        isMinus = true
        s = drop(s, 1)

    let hasDigits = false
    let x = 0
    data digits [char]
    while s.at(0) -> *char(c) | isDigit(c)
        hasDigits = true
        digits += [c]
        s = drop(s, 1)

    for digits[..] -> i
        x = x*10 + i64(digits[len(digits) - i - 1] - '0')

    if !hasDigits
        return fail
    if isMinus
        x = 0 - x
    return (conv(x), s)

