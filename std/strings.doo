module strings
import chars



fn {s string} at(i i64) {null | char}
    if s[..][i]; return conv (s[i])
    else;        return null


fn {s string, sub string} isPrefix() bool
    let count = 0
    for sub[..] -> i | s[..][i] | s[i] == sub[i]
        count = count + 1

    return count == sub.len()
    

fn {s string} find(c char) {null | i64}
    for s[..] -> i
        if c == s[i]
            return conv(i)
    return null


fn {s string, sub string} find() {null | i64}
    for s[..] -> i
        let matched = 0
        for s[i..] -> j | matched < sub.len() && s[j] == sub[matched]
            matched = matched + 1

        if matched == sub.len()
            return conv(i)

    return null


fn {s string} writeChar(c char)
    s.push(c)


fn {s string} writeBool(b bool)
    if b; {s, "true"}.writeString()
    else; {s, "false"}.writeString()


fn {s string, s2 string} writeString()
    for s2 -> c; s.push(c)


fn {s string} writeI64(n i64)
    if n == 0
        s.push('0')
        return

    if n < 0
        s.push('-')
        n = -n

    data digits [i64]
    while n != 0
        digits.push(n % 10)
        n = n / 10
    while digits.len() > 0
        s.push('0' + char(digits.pop()))


fn {s string} read(start i64, x char) i64
    let spaceCount = 0
    for s[start..] -> i | s[i] -> c | isSpace(c)
        spaceCount = spaceCount + 1

    for s[start + spaceCount..] -> i | s[i] -> c | c == x
        return start + spaceCount + 1
    return 0


fn {s string} read(start i64) (i64, i64)
    let spaceCount = 0
    for s[start..] -> i | isSpace(s[i])
        spaceCount = spaceCount + 1

    let n = 0
    let digitCount = 0
    for s[start+spaceCount..] -> i | isDigit(s[i]) || s[i] == '0'
        n = n*10 + i64(s[i] - '0')
        digitCount = digitCount + 1

    if digitCount > 0; return (n, start + spaceCount + digitCount)
    return (0, 0)
        
    
