module strings

import std/maybe
import std/table


fn isAlpha(c:char) bool
    let r = false
    ${ $r = isalpha($c); }
    return r


fn isDigit(c:char) bool
    let r = false
    ${ $r = isdigit($c); }
    return r


fn isSpace(c:char) bool
    let r = false
    ${ $r = isspace($c); }
    return r


//fn isPrefix(pre:string, str:string) bool
//    if len(pre) > len(str); return false
//    for pre[..] -> i
//        if str[i] != pre[i]; return false
//    return true
//
//
//fn {s:string} at(idx:i64) (null | char)
//    if idx >= 0 && idx < len(s)
//        return conv(s[idx])
//    return null
//
//
fn drop(s:string, n:i64) string
    let r = ""
    ${
        if ($n <= strlen($s)) {
            $r = $s + $n;
        }
    }
    return r
//
//
//fn take(s:string, n:i64) string
//    let r = ""
//    ${
//        size_t len = strlen($s);
//        if ($n >= len) {
//            $r = $s;
//        } else {
//            $r = doodad_string_alloc($n);
//            memcpy($r, $s, $n);
//            $r[$n] = '\0';
//        }
//    }
//    return r
//
//


fn get(s:string, idx:i64) Maybe(char)
    if idx >= 0 && idx < len(s)
        return Just(s[idx])
    return Nothing()


fn readI64(s:string) Maybe((i64, string))
    while get(s, 0) -> Just(c) | isSpace(c)
        s = drop(s, 1)

    let isMinus = false
    if get(s, 0) -> Just('-')
        isMinus = true
        s = drop(s, 1)

    let hasDigits = false
    let x = 0
    data digits []char
    while get(s, 0) -> Just(c) | isDigit(c)
        hasDigits = true
        digits.push(c)
        s = drop(s, 1)

    for digits -> {digit}
        x = x*10 + conv(digit - '0'):i64

    if !hasDigits
        return Nothing()
    if isMinus
        x = 0 - x
    return Just((x, s))

