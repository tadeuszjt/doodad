module binaryTree

import std/maybe
import std/unordered

type{K, V} Node (Maybe{unordered::Key{Node{K, V}}}, Maybe{Key{Node{K, V}}}, K, V)

fn{K, V} left(n &Node{K, V})  &Node{K, V}.Key.Maybe; return &n.0
fn{K, V} right(n &Node{K, V}) &Node{K, V}.Key.Maybe; return &n.1
fn{K, V} key(n &Node{K, V})   &K                   ; return &n.2
fn{K, V} value(n &Node{K, V}) &V                   ; return &n.3

type{K, V} Tree (Node{K, V}.Unordered, Node{K, V}.Key.Maybe)

fn{K, V} nodes(t &Tree{K, V}) &Node{K, V}.Unordered; return &t.0
fn{K, V} base(t &Tree{K, V})  &Node{K, V}.Key.Maybe; return &t.1


fn{K, V} len(tree &Tree{K, V}) I64
    return tree.nodes.len()


fn{K, V} at(tree &Tree{K, V}, key K) &V
    switch tree.base
        Node{K, V}.Key(current)
            while tree.nodes[current].key != key   
                if tree.nodes[current].left -> Node{K, V}.Key(left) | key < tree.nodes[current].key
                    current = left
                else if tree.nodes[current].right -> Node{K, V}.Key(right) | key > tree.nodes[current].key
                    current = right
                else
                    assert(false, "error")

            return tree.nodes[current].value

fn{K, V} insert(tree &Tree{K, V}, key K, value V)
    fn{K, V} insertNode(n &Node{K, V}.Unordered, newNode Node{K, V}.Key, node Node{K, V}.Key)
        let lt = n[newNode].key < n[node].key
        let gt = n[newNode].key > n[node].key

        if      n[node].left -> Node{K, V}.Key(left)   | lt; n.insertNode(newNode, left)
        else if n[node].right -> Node{K, V}.Key(right) | gt; n.insertNode(newNode, right)
        else if n[node].left -> Nothing()    | lt; n[node].left = conv(newNode)
        else if n[node].right -> Nothing()   | gt; n[node].right = conv(newNode)
        else; assert(false, "key already in tree")

    let nodeKey = tree.nodes.insert()
    tree.nodes[nodeKey].key = key
    tree.nodes[nodeKey].value = value
    switch tree.base
        Nothing()                ; tree.base = conv(nodeKey)
        Key{Node{K, V}}(baseNode); tree.nodes.insertNode(nodeKey, baseNode)
//
//
//fn[K, V] {tree Tree[K, V]} delete(key ()K) 
//    fn[K, V] {nodes Unordered[Node[K, V]]} leftMost(node Key[Node[K, V]]) Key[Node[K, V]]
//        if nodes[node].left -> Just(left)
//            return nodes.leftMost(left)
//        return node
//
//    fn[K, V] {nodes Unordered[Node[K, V]]} rightMost(node Key[Node[K, V]]) Key[Node[K, V]]
//        if nodes[node].right -> Just(right)
//            return nodes.rightMost(right)
//        return node
//
//    fn[K, V] {n Unordered[Node[K, V]]} deleteFromNode(node Key[Node[K, V]], key ()K)
//        assert(key{} != n[node].key{}, "key cannot match current node")
//        let leftm  = n.get(node).left
//        let rightm = n.get(node).right
//
//        if leftm -> Just(left) | key{} == n.at(left).key{} // deleting node on left
//            if n.get(left).right -> Just(leftRight)
//                let leftMost        = n.leftMost(leftRight)
//                n.at(leftMost).left = n.get(left).left
//                n[node].left     = Just(leftRight)
//            else; n[node].left   = n.get(left).left
//            n.delete(left)
//
//        else if rightm -> Just(right) | key{} == n.at(right).key{} // deleting from right
//            if n.get(right).left -> Just(rightLeft)
//                let rightMost         = n.rightMost(rightLeft)
//                n.at(rightMost).right = n.get(right).right
//                n[node].right      = Just(rightLeft)
//            else; n[node].right    = n.get(right).right
//            n.delete(right)
//                
//        else if leftm -> Just(left) | key{} < n[node].key{}
//            n.deleteFromNode(left, key)
//    
//        else if rightm -> Just(right) | key{} > n[node].key{}
//            n.deleteFromNode(right, key)
//
//        else; assert(false, "invalid key")
//
//    switch tree.base
//        Just(base)
//            if tree.nodes.at(base).key{} == key{}
//                if tree.nodes.at(base).left -> Just(left)
//                    tree.base = Just(left)
//                    tree.nodes.at(tree.nodes.rightMost(left)).right = tree.nodes.get(base).right
//                else if tree.nodes.at(base).right -> Just(right)
//                    tree.base = Just(right)
//                    tree.nodes.at(tree.nodes.leftMost(right)).left = tree.nodes.get(base).left
//                else; tree.base = Nothing()
//                tree.nodes.delete(base)
//            else; tree.nodes.deleteFromNode(base, key)
//
//
//fn[K, V] {tree Tree[K, V]} contains(key ()K) Bool
//    fn[K, V] {tree Tree[K, V]} nodeContains(node Key[Node[K, V]], key ()K) Bool
//        let (less, greater, mLeft, mRight)
//        let {l, r, k, v} = tree.nodes[node] in
//            mLeft   = l
//            mRight  = r
//            less    = key{} < k{}
//            greater = key{} > k{}
//
//        if      !less && !greater              ; return true
//        else if mLeft  -> Just(left)  | less   ; return tree.nodeContains(left, key)
//        else if mRight -> Just(right) | greater; return tree.nodeContains(right, key)
//        else                                   ; return false
//
//    switch tree.base
//        Nothing();  return false
//        Just(base); return tree.nodeContains(base, key)
