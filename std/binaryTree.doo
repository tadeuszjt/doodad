module binaryTree

import std/maybe
import std/unordered

type[K, V] Node {
    left  : Maybe( unordered::Key( Node(K, V) ) )
    right : Maybe( unordered::Key( Node(K, V) ) )
    key   : K
    value : V
}

type[K, V] Tree (
    nodes : Unordered( Node(K, V) )
    base  : Maybe( unordered::Key( Node(K, V) ) )
)



fn[K, V] {tree : Tree(K, V)} length() i64
    return tree.nodes.length()


fn[K, V] {tree : Tree(K, V)} get(key : ()K) ()V
    switch tree.base
        Just(node)
            while tree.nodes.at(node).key{} != key{}
                if      tree.nodes.at(node).left -> Just(left)   | key{} < tree.nodes.at(node).key{}; node = left
                else if tree.nodes.at(node).right -> Just(right) | key{} > tree.nodes.at(node).key{}; node = right
                else; assert(false, "error")

            data value ()V
            value{} = tree.nodes.at(node).value{}
            return value


fn[K, V] {tree : Tree(K, V)} insert(key : ()K, value : ()V)
    fn[K, V] {tree : Tree(K, V)} insertNode(newNode : Key(Node(K, V)), node : Key(Node(K, V)))
        let lt = tree.nodes.at(newNode).key < tree.nodes.at(node).key
        let gt = tree.nodes.at(newNode).key > tree.nodes.at(node).key
        let {l, r, k, v} = tree.nodes.at(node) in
            if !lt && !gt                ; assert(false, "key already in tree")
            else if l -> Just(left)  | lt; tree.insertNode(newNode, left)
            else if r -> Just(right) | gt; tree.insertNode(newNode, right)
            else if l -> Nothing()   | lt; l = Just(newNode)
            else if r -> Nothing()   | gt; r = Just(newNode)

    let nodeKey = tree.nodes.insert()
    tree.nodes.at(nodeKey).key{}   = key{}
    tree.nodes.at(nodeKey).value{} = value{}
    switch tree.base
        Nothing(); tree.base = Just(nodeKey)
        Just(baseNode)
            tree.insertNode(nodeKey, baseNode)


fn[K, V] {tree : Tree(K, V)} delete(key : ()K) 
    fn[K, V] {tree : Tree(K, V)} leftMost(node : Key( Node(K, V) )) Key(Node(K, V))
        if tree.nodes.at(node) -> {Just(left), _, _, _}
            return tree.leftMost(left)
        return node

    fn[K, V] {tree : Tree(K, V)} rightMost(node : Key( Node(K, V) )) Key(Node(K, V))
        if tree.nodes.at(node) -> {_, Just(right), _, _}
            return tree.rightMost(right)
        return node

    fn[K, V] {tree : Tree(K, V)} deleteFromNode(node : Key( Node(K, V) ), key : ()K)
        assert(key{} != tree.nodes.at(node).key{}, "key cannot match current node")
        let leftm  = tree.nodes.get(node).left
        let rightm = tree.nodes.get(node).right

        if leftm -> Just(left) | key{} == tree.nodes.at(left).key{} // deleting node on left
            if tree.nodes.get(left).right -> Just(leftRight)
                let leftMost                 = tree.leftMost(leftRight)
                tree.nodes.at(leftMost).left = tree.nodes.at(left).left
                tree.nodes.at(node).left     = Just(leftRight)
            else
                tree.nodes.at(node).left = tree.nodes.at(left).left
            tree.nodes.delete(left)

        else if rightm -> Just(right) | key{} == tree.nodes.at(right).key{} // deleting from right
            if tree.nodes.get(right).left -> Just(rightLeft)
                let rightMost                  = tree.rightMost(rightLeft)
                tree.nodes.at(rightMost).right = tree.nodes.at(right).right
                tree.nodes.at(node).right      = Just(rightLeft)
            else
                tree.nodes.at(node).right = tree.nodes.at(right).right
            tree.nodes.delete(right)
                
        else if leftm -> Just(left) | key{} < tree.nodes.at(node).key{}
            tree.deleteFromNode(left, key)
    
        else if rightm -> Just(right) | key{} > tree.nodes.at(node).key{}
            tree.deleteFromNode(right, key)

        else; assert(false, "invalid key")

    switch tree.base
        Just(base)
            if tree.nodes.at(base).key{} == key{}
                if tree.nodes.at(base).left -> Just(left)
                    tree.base = Just(left)
                    tree.nodes.at(tree.rightMost(left)).right = tree.nodes.at(base).right
                else if tree.nodes.at(base).right -> Just(right)
                    tree.base = Just(right)
                    tree.nodes.at(tree.rightMost(right)).left = tree.nodes.at(base).left
                else
                    tree.base = Nothing()
                tree.nodes.delete(base)
            else; tree.deleteFromNode(base, key)


fn[K, V] {tree : Tree(K, V)} contains(key : ()K) bool
    fn[K, V] {tree : Tree(K, V)} nodeContains(node : Key( Node(K, V) ), key : ()K) bool
        let {l, r, k, v} = tree.nodes.at(node) in
            let lt = key{} < k{}
            let gt = key{} > k{}
            if  !lt  &&  !gt             ; return true
            else if l -> Just(left)  | lt; return tree.nodeContains(left, key)
            else if r -> Just(right) | gt; return tree.nodeContains(right, key)
            else                         ; return false

    switch tree.base
        Nothing(); return false
        Just(base); return tree.nodeContains(base, key)
