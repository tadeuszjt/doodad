module binaryTree

import std/maybe
import std/unordered

type[K, V] TreeElem { key:K, value:V }

type[K, V] TreeNode = (
    NodeLeaf : UnorderedKey(TreeElem(K, V)) |
    NodeBranch : (
        Key(TreeNode(K, V)),
        Key(TreeNode(K, V)),
        ()K
    )
)

type[K, V] Tree (
    base  : Maybe( Key(TreeNode(K, V)) )
    nodes : Sparse( TreeNode(K, V) )
    elems : Unordered( TreeElem(K, V) )
)


fn[K, V] {tree:Tree(K, V)} insert(key:()K, value:()V)
    let elemKey = tree.elems.insert()
    let {k, v}  = tree.elems.at(elemKey) in
        k{} = key{}
        v{} = value{}

    let newNodeKey = tree.nodes.insert(NodeLeaf(elemKey))

    switch tree.base
        Nothing(); tree.base = Just(newNodeKey)
        Just(baseNodeKey)
            
            // set nodeKey to the appropriate leaf
            let nodeKey = baseNodeKey
            while tree.nodes.at(nodeKey) -> {NodeBranch((left, right, branchKey))}
                if key < branchKey; nodeKey = left
                else;               nodeKey = right

            // construct new leaf and branch
            let leafKey = tree.nodes.insert( tree.nodes.get(nodeKey) ) // set new leaf to node
            let branch = NodeBranch((leafKey, newNodeKey, key)):TreeNode(K, V)
            let NodeLeaf(oldElemKey) = tree.nodes.get(nodeKey) in
                let {k, _} = tree.elems.at(oldElemKey) in
                    if key{} < k{}
                        data x ()K
                        x{} = k{}
                        branch = NodeBranch((newNodeKey, leafKey, x))

            tree.nodes.at(nodeKey) = branch{}



fn[K, V] {tree:Tree(K, V)} contains(key:()K) bool
    fn[K, V] {tree:Tree(K, V)} contains(nodeKey:Key(TreeNode(K, V)), key:()K) bool
        switch tree.nodes.at(nodeKey)
            {NodeLeaf( elemKey )}; return tree.elems.at(elemKey).key{} == key{}
            {NodeBranch((left, right, k))}
                if key < k; return tree.contains(left, key)
                else      ; return tree.contains(right, key)
    
    switch tree.base
        Nothing();         return false
        Just(baseNodeKey); return tree.contains(baseNodeKey, key)


fn[K, V] {tree:Tree(K, V)} length() i64
    return tree.elems.length()

