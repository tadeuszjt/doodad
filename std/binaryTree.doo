module binaryTree

import std/maybe
import std/unordered

type[K, V] TreeElem { key:K, value:V }

type[K, V] TreeNode = (
    NodeLeaf : UnorderedKey(TreeElem(K, V)) |
    NodeBranch : (
        SparseKey(TreeNode(K, V)),
        SparseKey(TreeNode(K, V)),
        ()K
    )
)

type[K, V] Tree (
    base  : Maybe( SparseKey(TreeNode(K, V)) )
    nodes : Sparse( TreeNode(K, V) )
    elems : Unordered( TreeElem(K, V) )
)


fn[K, V] {tree:Tree(K, V)} insert(key:()K, value:()V)
    let elemKey = tree.elems.insert()
    let {k, v}  = tree.elems.at(elemKey) in
        k{} = key{}
        v{} = value{}
    let leafNew = tree.nodes.insert(NodeLeaf(elemKey))

    switch tree.base
        Nothing(); tree.base = Just(leafNew)
        Just(baseNodeKey)
            // set leaf to the appropriate leaf
            let leaf = baseNodeKey
            while tree.nodes.at(leaf) -> {NodeBranch(left, right, k)}
                if key < k; leaf = left
                else;       leaf = right
            let NodeLeaf(ek) = tree.nodes.get(leaf)

            // check the key is not already in the tree as this would invalidate the structure
            if key{} == tree.elems.at(ek).key{}
                print("tree already contains key:", key)
                let true = false

            // construct new leaf and branch
            let leafCopy = tree.nodes.insert( NodeLeaf(ek) ) // set new leaf to node
            let branch = NodeBranch(leafCopy, leafNew, key):TreeNode(K, V)
            let {k, _} = tree.elems.at(ek) in
                if key{} < k{}
                    data x ()K
                    x{} = k{}
                    branch = NodeBranch(leafNew, leafCopy, x)

            tree.nodes.at(leaf) = branch{}


fn[K, V] {tree:Tree(K, V)} delete(key:()K)
    fn[K, V] {tree:Tree(K, V)} deleteFromBranch(nodeKey:SparseKey(TreeNode(K, V)), key:()K)
        let NodeBranch(left, right, k) = tree.nodes.get(nodeKey)
        let (x, y) = (left, right)
        if key < k
            x = right
            y = left

        switch tree.nodes.get(y)
            NodeBranch(_); tree.deleteFromBranch(y, key)
            NodeLeaf(elem)
                let true = key{} == tree.elems.at(elem).key{}
                tree.nodes.at(nodeKey) = tree.nodes.at(x)
                tree.elems.delete(elem)
                tree.nodes.delete(x)
                tree.nodes.delete(y)

    switch tree.base
        Just(baseNodeKey)
            switch tree.nodes.get(baseNodeKey)
                NodeBranch(_); tree.deleteFromBranch(baseNodeKey, key)
                NodeLeaf(elemKey)
                    let true = key{} == tree.elems.at(elemKey).key{}
                    tree.elems.delete(elemKey)
                    tree.nodes.delete(baseNodeKey)
                    tree.base = Nothing()


fn[K, V] {tree:Tree(K, V)} contains(key:()K) bool
    fn[K, V] {tree:Tree(K, V)} contains(nodeKey:SparseKey(TreeNode(K, V)), key:()K) bool
        switch tree.nodes.get(nodeKey)
            NodeLeaf(elemKey); return tree.elems.at(elemKey).key{} == key{}
            NodeBranch(left, right, k)
                if key < k; return tree.contains(left, key)
                else      ; return tree.contains(right, key)
    
    switch tree.base
        Nothing();         return false
        Just(baseNodeKey); return tree.contains(baseNodeKey, key)


fn[K, V] {tree:Tree(K, V)} get(key:()K) ()V
    fn[K, V] {tree:Tree(K, V)} getFromNode(nodeKey:SparseKey(TreeNode(K, V)), key:()K) ()V
        switch tree.nodes.get(nodeKey)
            NodeLeaf(elemKey)
                let true = key{} == tree.elems.at(elemKey).key{}
                data value ()V
                value{} = tree.elems.at(elemKey).value{}
                return value

            NodeBranch(left, right, k)
                if key < k; return tree.getFromNode(left, key)
                else;       return tree.getFromNode(right, key)

    let Just(baseNodeKey) = tree.base
    return tree.getFromNode(baseNodeKey, key)


fn[K, V] {tree:Tree(K, V)} length() i64
    return tree.elems.length()

