module binaryTree

import std/maybe
import std/unordered

type[K, V] TreeElem { key:K, value:V }

type[K, V] TreeNode = (
    NodeLeaf : UnorderedKey(TreeElem(K, V)) |
    NodeBranch : (
        Key(TreeNode(K, V)),
        Key(TreeNode(K, V)),
        ()K
    )
)

type[K, V] Tree (
    base  : Maybe( Key(TreeNode(K, V)) )
    nodes : Sparse( TreeNode(K, V) )
    elems : Unordered( TreeElem(K, V) )
)


fn[K, V] {tree:Tree(K, V)} insert(key:()K, value:()V)
    let elemKey = tree.elems.insert()
    let {k, v}  = tree.elems.at(elemKey) in
        k{} = key{}
        v{} = value{}
    let newNodeKey = tree.nodes.insert(NodeLeaf(elemKey))

    switch tree.base
        Nothing(); tree.base = Just(newNodeKey)
        Just(baseNodeKey)
            
            // set nodeKey to the appropriate leaf
            let nodeKey = baseNodeKey
            while tree.nodes.at(nodeKey) -> {NodeBranch((left, right, k))}
                if key < k; nodeKey = left
                else;       nodeKey = right

            // construct new leaf and branch
            let leafKey = tree.nodes.insert( tree.nodes.get(nodeKey) ) // set new leaf to node
            let branch = NodeBranch((leafKey, newNodeKey, key)):TreeNode(K, V)
            let NodeLeaf(oldElemKey) = tree.nodes.get(nodeKey) in
                let {k, _} = tree.elems.at(oldElemKey) in
                    if key{} < k{}
                        data x ()K
                        x{} = k{}
                        branch = NodeBranch((newNodeKey, leafKey, x))

            tree.nodes.at(nodeKey) = branch{}


fn[K, V] {tree:Tree(K, V)} delete(key:()K)
    fn[K, V] {tree:Tree(K, V)} deleteFromBranch(nodeKey:Key(TreeNode(K, V)), key:()K)
        let NodeBranch((left, right, k)) = tree.nodes.get(nodeKey)
        //print("from branch", left, right, key, k)
        if key < k
            switch tree.nodes.get(left)
                NodeBranch(_)
                    //print("go left")
                    tree.deleteFromBranch(left, key)
                NodeLeaf(elemKey)
                    //print("left leaf", elemKey, tree.elems.at(elemKey), left, right)
                    let b = key{} == tree.elems.at(elemKey).key{}
                    if !b
                        print("here", key, tree.elems.at(elemKey).key{}, k)
                        let true = false

                    tree.nodes.at(nodeKey) = tree.nodes.at(right)
                    tree.elems.delete(elemKey)
                    tree.nodes.delete(left)
                    tree.nodes.delete(right)
        else
            switch tree.nodes.get(right)
                NodeBranch(_)
                    //print("go right")
                    tree.deleteFromBranch(right, key)
                NodeLeaf(elemKey)
                    //print("right leaf", elemKey, tree.elems.at(elemKey))

                    //print("right leaf", elemKey)
                    let true = key{} == tree.elems.at(elemKey).key{}
                    tree.nodes.at(nodeKey) = tree.nodes.at(left)
                    tree.elems.delete(elemKey)
                    tree.nodes.delete(left)
                    tree.nodes.delete(right)

    switch tree.base
        Just(baseNodeKey)
            switch tree.nodes.get(baseNodeKey)
                NodeBranch(_); tree.deleteFromBranch(baseNodeKey, key)
                NodeLeaf(elemKey)
                    let true = key{} == tree.elems.at(elemKey).key{}
                    tree.elems.delete(elemKey)
                    tree.nodes.delete(baseNodeKey)
                    tree.base = Nothing()


fn[K, V] {tree:Tree(K, V)} contains(key:()K) bool
    fn[K, V] {tree:Tree(K, V)} contains(nodeKey:Key(TreeNode(K, V)), key:()K) bool
        switch tree.nodes.get(nodeKey)
            NodeLeaf(elemKey); return tree.elems.at(elemKey).key{} == key{}
            NodeBranch((left, right, k))
                if key < k; return tree.contains(left, key)
                else      ; return tree.contains(right, key)
    
    switch tree.base
        Nothing();         return false
        Just(baseNodeKey); return tree.contains(baseNodeKey, key)


fn[K, V] {tree:Tree(K, V)} get(key:()K) ()V
    fn[K, V] {tree:Tree(K, V)} getFromNode(nodeKey:Key(TreeNode(K, V)), key:()K) ()V
        switch tree.nodes.get(nodeKey)
            NodeLeaf(elemKey)
                let true = key{} == tree.elems.at(elemKey).key{}
                data value ()V
                value{} = tree.elems.at(elemKey).value{}
                return value

            NodeBranch((left, right, k))
                if key < k; return tree.getFromNode(left, key)
                else;       return tree.getFromNode(right, key)

    let Just(baseNodeKey) = tree.base
    return tree.getFromNode(baseNodeKey, key)


fn[K, V] {tree:Tree(K, V)} length() i64
    return tree.elems.length()

