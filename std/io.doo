module io

import std/map


type Io Tuple{
    Map{I64, Bool},
    StdOut,
}

fn stdout(io &Io) &StdOut; return &io.1

type StdOut Tuple{}


fn append(stdout &StdOut, c Char); ${ putchar($c); }
fn append(stdout &StdOut, x I64); ${ printf("%d", $x); }
fn append(stdout &StdOut, x Bool); ${ fputs($x ? "true" : "false", stdout); }
fn append(stdout &StdOut, s []Char)
    for s -> c
        stdout += c

fn{A, B} append(stdout &StdOut, x Tuple{A, B})
    stdout += '('
    stdout += x.0
    stdout += ", "
    stdout += x.1
    stdout += ')'

fn{A} append(stdout &StdOut, table &A.Table)
    stdout += '['
    for (0, table.len) -> i
        stdout += table[i]
        if i < (table.len - 1)
            stdout += ", "
    stdout += ']'

//
//fn {io Io} openFile(fileName String)
//    assert(!io.files.contains(fileName), fileName + " already open")
//    let ptr = 0
//    ${
//        FILE *fp = fopen($fileName, "w+");
//        assert(fp != NULL);
//        $ptr = (int64_t)(fp);
//    }
//    io.files.insert(fileName, ptr)
//
//
//fn {io Io} closeFile(fileName String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fclose((FILE*)$ptr); }
//    io.files.delete(fileName)
//
//
//fn {io Io} fPutStr(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s", $str); }
//
//
//fn {io Io} fPutStrLn(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s\n", $str); }
//
//
//fn {io Io} putStrLn(s String)
//    ${ printf("%s\n", $s); }
//
//
//fn {io Io} putStr(s String)
//    ${ printf("%s", $s); }


