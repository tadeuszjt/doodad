module io

import std/map
import std/char
import std/table
import std/integer


type Io Tuple{
    Map{I64, Bool},
    StdOut,
    StdIn,
}

type StdOut Tuple{}
type StdIn  Tuple{}

fn stdout(io &Io) &StdOut; return &io.1
fn stdin (io &Io) &StdIn ; return &io.2

fn append(stdout &StdOut, c Char) &StdOut
    ${ putchar($c); }
    return stdout

fn append(stdout &StdOut, x I64) &StdOut
    ${ printf("%d", $x); }
    return stdout

fn append(stdout &StdOut, x Bool) &StdOut
    ${ fputs($x ? "true" : "false", stdout); }
    return stdout

fn append(stdout &StdOut, s []Char) &StdOut
    for s -> c
        stdout += c
    return stdout

fn{A, B} append(stdout &StdOut, x Tuple{A, B}) &StdOut
    stdout += '('
    stdout += x.0
    stdout += ", "
    stdout += x.1
    stdout += ')'
    return stdout

fn{A} append(stdout &StdOut, table &A.Table) &StdOut
    stdout += '['
    for (0, table.len) -> i
        stdout += table[i]
        if i < (table.len - 1)
            stdout += ", "
    stdout += ']'
    return stdout

fn append(stdout &StdOut, table &Char.Table) &StdOut
    for (0, table.len) -> i
        stdout += table[i]
    return stdout


fn getChar(stdin &StdIn) Char
    let c : Char
    ${ $c = fgetc(stdin); }
    return c


fn getLine(stdin &StdIn, line &Char.Table) Bool
    while true
        switch stdin.getChar
            '\n'          ; return true
            x | x == eof(); return false
            x             ; line += x
    

//
//fn {io Io} openFile(fileName String)
//    assert(!io.files.contains(fileName), fileName + " already open")
//    let ptr = 0
//    ${
//        FILE *fp = fopen($fileName, "w+");
//        assert(fp != NULL);
//        $ptr = (int64_t)(fp);
//    }
//    io.files.insert(fileName, ptr)
//
//
//fn {io Io} closeFile(fileName String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fclose((FILE*)$ptr); }
//    io.files.delete(fileName)
//
//
//fn {io Io} fPutStr(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s", $str); }
//
//
//fn {io Io} fPutStrLn(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s\n", $str); }
//
//
//fn {io Io} putStrLn(s String)
//    ${ printf("%s\n", $s); }
//
//
//fn {io Io} putStr(s String)
//    ${ printf("%s", $s); }


