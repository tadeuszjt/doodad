module io

import std/map
import std/char
import std/table
import std/integer
import std/push
import std/tuple
import std/bool
import std/features
import std/slice


type Io Tuple{
    Map{I64, Bool},
    StdOut,
    StdIn,
}

type StdOut Tuple{}
type StdIn  Tuple{}

fn stdout(io &Io) &StdOut; return &io.1
fn stdin (io &Io) &StdIn ; return &io.2

fn push(stdout &StdOut, c Char)
    ${ putchar($c); }

fn push(stdout &StdOut, x I64)
    ${ printf("%d", $x); }

fn push(stdout &StdOut, x Bool)
    ${ fputs($x ? "true" : "false", stdout); }

fn push(stdout &StdOut, s []Char)
    for s -> c
        stdout.push(c)

fn{A, B} push(stdout &StdOut, x Tuple{A, B})
    stdout.push('(', x.0, ", ", x.1, ')')

fn{A} push(stdout &StdOut, table &A.Table)
    stdout.push('[')
    for (0, table.len) -> i
        stdout.push(table[i])
        if i < (table.len - 1)
            stdout.push(", ")
    stdout.push(']')


fn push(stdout &StdOut, table &Char.Table)
    for (0, table.len) -> i
        stdout.push(table[i])
        

fn getChar(stdin &StdIn) Char
    let c : Char
    ${ $c = fgetc(stdin); }
    return c


fn getLine(stdin &StdIn, line &Char.Table) Bool
    while true
        switch stdin.getChar
            '\n'          ; return true
            x | x == eof(); return false
            x             ; line.push(x)
    

//
//fn {io Io} openFile(fileName String)
//    assert(!io.files.contains(fileName), fileName + " already open")
//    let ptr = 0
//    ${
//        FILE *fp = fopen($fileName, "w+");
//        assert(fp != NULL);
//        $ptr = (int64_t)(fp);
//    }
//    io.files.insert(fileName, ptr)
//
//
//fn {io Io} closeFile(fileName String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fclose((FILE*)$ptr); }
//    io.files.delete(fileName)
//
//
//fn {io Io} fPutStr(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s", $str); }
//
//
//fn {io Io} fPutStrLn(fileName String, str String)
//    assert(io.files.contains(fileName), fileName + " is not open")
//    let Just(ptr) = io.files.find(fileName)
//    ${ fprintf((FILE*)$ptr, "%s\n", $str); }
//
//
//fn {io Io} putStrLn(s String)
//    ${ printf("%s\n", $s); }
//
//
//fn {io Io} putStr(s String)
//    ${ printf("%s", $s); }


