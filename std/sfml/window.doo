module sfml

import std/builtin
import std/store
import std/assert
import std/tuple
import std/option
import std/arithmetic
import std/boolean
import std/convert
import std/container

include <SFML/Graphics.h>
link csfml-graphics
link csfml-window
link csfml-system


tuple Vec2f {
    x F32
    y F32
}
derives Vec2f (store)
derives Vec2f (arithmetic::add)

fn vec2f(x F32, y F32) Vec2f
    let vec
    vec.x = x
    vec.y = y
    return vec


tuple Rectf {
    min Vec2f
    max Vec2f
}

tuple Colour {
    a U8
    r U8
    g U8
    b U8
}
derives Colour (store)

fn makecolour(a U8, r U8, g U8, b U8) Colour
    let colour
    colour.a = a
    colour.r = r
    colour.g = g
    colour.b = b
    return colour

fn white() Colour; return makecolour(255, 255, 255, 255)
fn black() Colour; return makecolour(255, 0, 0, 0)


tuple Vertex {
    position Vec2f
    colour   Colour
    texCoord Vec2f
}
derives Vertex (store)

fn vertex(position Vec2f, colour Colour, texCoord Vec2f) Vertex
    let vert
    vert.position = position
    vert.colour = colour
    vert.texCoord = texCoord
    return vert


type Quad Array{6, sfml::Vertex}
fn tri(quad &Quad, i I64) &Vertex; return quad.pretend:Array{6, Vertex}[i]


type Window I64

enum Event {
    closed
}
derives Event (store)


fn create(w &Window)
    ${
        sfVideoMode mode = {640, 480, 32};
        sfRenderWindow *window = sfRenderWindow_create(mode, "graphicsTest", sfClose | sfResize, NULL);
        assert(window != NULL);
        *$w = (int64_t)(window);
    }


fn close(w &Window)
    ${ sfRenderWindow_close((sfRenderWindow*)(*$w)); }


fn destroy(w &Window)
    ${ sfRenderWindow_close((sfRenderWindow*)(*$w)); }
    ${ *$w = (int64_t)NULL; }


fn getSize(w &Window) (I64, I64)
    let x = 0
    let y = 0
    ${
        sfVector2u vec = sfRenderWindow_getSize((sfRenderWindow*)(*$w));
        $x = vec.x;
        $y = vec.y;
    }
    return (x, y)


fn clearWindow(w &Window, colour Colour)
    ${
        sfColor color = {$colour.m0, $colour.m1, $colour.m2, $colour.m3};
        sfRenderWindow_clear((sfRenderWindow*)(*$w), color);
    }


fn display(w &Window)
    ${ sfRenderWindow_display((sfRenderWindow*)(*$w)); }


fn isOpen(w &Window) Bool
    let isOpen = false
    ${ $isOpen = sfRenderWindow_isOpen((sfRenderWindow*)(*$w)); }
    return isOpen


fn pollEvent(w &Window) Event.Option
    let continue = false
    let event:Event
    let isNone = false

    ${
        sfEvent event;
        $continue = sfRenderWindow_pollEvent((sfRenderWindow*)(*$w), &event);
        if (event.type == sfEvtClosed) {
            $event.en = 0;
        } else {
            $isNone = true;
        }
    }

    if isNone
        return Option::none()

    if continue && !isNone
        return Option::some(event)
    return Option::none()


fn drawQuads(w &Window, quads &Quad.Table)
    ${
        sfRenderWindow_drawPrimitives(
            (sfRenderWindow*)*$w,
            (const sfVertex *)$quads->r0,
            $quads->len * 6,
            sfTriangles,
            NULL
        );
    }

////fn {w Window} setViewFromRect(rect Rectf)
////    let (l, t, r, b) = (rect.min.x, rect.min.y, rect.max.x, rect.max.y)
////    ${
////        sfFloatRect rect = {$l, $t, $r, $b};
////        sfView *view = sfView_createFromRect(rect);
////        sfRenderWindow_setView((sfRenderWindow*)(*$w), view);
////    }
