module sfml

import std/builtin
import std/store
import std/assert
import std/tuple
import std/option
import std/arithmetic
import std/boolean
import std/convert
import std/container
import std/print
import std/sparse
import std/destroy

include <SFML/Graphics.h>
link csfml-graphics
link csfml-window
link csfml-system


tuple Vec2f {
    x F32
    y F32
}
derives    Vec2f (store)
derives    Vec2f (builtin::destroy)
derives    Vec2f (make2{F32, F32})
derives{P} Vec2f (print::print{P})
acquires arithmetic::add{ Vec2f, Vec2f } (a, b); return (a.x + b.x, a.y + b.y)


tuple Rectf {
    min Vec2f
    max Vec2f
}
derives Rectf (make2{Vec2f, Vec2f})


tuple Colour {
    r U8
    g U8
    b U8
    a U8
}
derives Colour (store)
derives Colour (builtin::destroy)
derives Colour (make4{U8, U8, U8, U8})
derives{P} Colour (print::print{P})

fn white() Colour; return (255, 255, 255, 255)
fn black() Colour; return (0, 0, 0, 255)


tuple Vertex {
    position Vec2f
    vertColour  Colour
    texCoord Vec2f
}
derives    Vertex (store)
derives    Vertex (builtin::destroy)
derives    Vertex (make3{Vec2f, Colour, Vec2f})
derives{P} Vertex (print::print{P})


type Quad Array{6, sfml::Vertex}
derives{P} Quad (print::print{P})
derives    Quad (container::at{ I64, Vertex })
derives    Quad (store::store)
derives    Quad (builtin::destroy)


tuple Window {
    windowPtr I64
    textures  Texture.Sparse
}
acquires destroy{Window} (w&)
    w.textures.destroy
    let ptr = w.windowPtr
    ${ sfRenderWindow_close((sfRenderWindow*)($ptr)); }



fn loadTextureFromFile(w &Window, fileName Char.Slice) Texture.sparse::Key
    let texturePtr = 0
    ${
        assert($fileName.len < 128);
        char filename[128] = {0};
        snprintf(filename, sizeof(filename), "%s", $fileName.ptr);
        sfTexture *texture = sfTexture_createFromFile(filename, NULL);
        assert(NULL != texture);
        $texturePtr = (int64_t)(texture);
    }

    let key = w.textures.insertZero
    w.textures[key].texturePtr = texturePtr
    return key



derives Texture (store::store)

tuple Texture {
    texturePtr I64
}
acquires destroy{Texture} (t&)
    let ptr = t.texturePtr
    ${ sfTexture_destroy((sfTexture*)$ptr); }
    


enum Event {
    closed
}
derives Event (store)
derives Event (builtin::destroy)


fn create(w &Window)
    let ptr = 0
    ${
        sfVideoMode mode = {640, 480, 32};
        sfRenderWindow *window = sfRenderWindow_create(mode, "graphicsTest", sfClose | sfResize, NULL);
        assert(window != NULL);
        $ptr = (int64_t)(window);
    }
    w.windowPtr = ptr


fn close(w &Window)
    let ptr = w.windowPtr
    ${ sfRenderWindow_close((sfRenderWindow*)($ptr)); }



fn getSize(w &Window) (I64, I64)
    let ptr = w.windowPtr
    let x = 0
    let y = 0
    ${
        sfVector2u vec = sfRenderWindow_getSize((sfRenderWindow*)($ptr));
        $x = vec.x;
        $y = vec.y;
    }
    return (x, y)


fn clearWindow(w &Window, colour Colour)
    let ptr = w.windowPtr
    ${
        sfColor color = {$colour.m0, $colour.m1, $colour.m2, $colour.m3};
        sfRenderWindow_clear((sfRenderWindow*)($ptr), color);
    }


fn display(w &Window)
    let ptr = w.windowPtr
    ${ sfRenderWindow_display((sfRenderWindow*)($ptr)); }


fn isOpen(w &Window) Bool
    let ptr = w.windowPtr
    let isOpen = false
    ${ $isOpen = sfRenderWindow_isOpen((sfRenderWindow*)($ptr)); }
    return isOpen


fn pollEvent(w &Window) Event.Option
    let ptr = w.windowPtr
    let continue = false
    let event:Event
    let isNone = false

    ${
        sfEvent event;
        $continue = sfRenderWindow_pollEvent((sfRenderWindow*)($ptr), &event);
        if (event.type == sfEvtClosed) {
            $event.en = 0;
        } else {
            $isNone = true;
        }
    }

    if isNone
        return Option::none()

    if continue && !isNone
        return Option::some(event)
    return Option::none()


fn drawQuads(w &Window, quads Slice{Quad})
    let ptr = w.windowPtr
    //let texturePtr = w.textures[texture].texturePtr
    let something = 0
    ${
        sfRenderStates states;
        states.texture = NULL;
        states.blendMode = sfBlendAlpha;
        states.transform = sfTransform_Identity;

        sfRenderWindow_drawPrimitives(
            (sfRenderWindow*)$ptr,
            (const sfVertex *)$quads.ptr,
            $quads.len * 6,
            sfTriangles,
            &states
        );
    }

fn setViewFromRect(w &Window, rect Rectf)
    let ptr = w.windowPtr
    let (l, t, r, b) = (rect.min.x, rect.min.y, rect.max.x, rect.max.y)
    ${
        sfFloatRect rect = {$l, $t, $r, $b};
        sfView *view = sfView_createFromRect(rect);
        sfRenderWindow_setView((sfRenderWindow*)($ptr), view);
    }
