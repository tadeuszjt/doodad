module destroy

import std/tuple
import std/convert
import std/container
import std/builtin
import std/for
import std/store
import std/compare


//feature{T} destroy(T)

acquires destroy{ U8 } (n&); return
//acquires destroy{ I64 } (n&); return
//acquires destroy{ F32 } (n&); return
//acquires destroy{ F64 } (n&); return


acquires{T} destroy{ Slice{T} } (slice&); return


acquires{A} destroy{ Tuple{A} } (tup&)
    tup.0 .destroy

acquires{A, B} destroy{ Tuple{A, B} } (tup&)
    tup.0 .destroy
    tup.1 .destroy

acquires{A, B, C} destroy{ Tuple{A, B, C} } (tup&)
    tup.0 .destroy
    tup.1 .destroy
    tup.2 .destroy

acquires{A, B, C, D} destroy{ Tuple{A, B, C, D} } (tup&)
    tup.0 .destroy
    tup.1 .destroy
    tup.2 .destroy
    tup.3 .destroy


acquires{N, T} destroy{ Array{N, T} } (arr&)
    for (0, arr.len) -> i
        arr[i].destroy
    

acquires{T} destroy{ T.Table } (t&)
    for (0, t.len) -> i
        ${ printf("destroying elem:%d\n", $i); }
        t[i].destroy
    ${
        printf("destroying table:%p\n", $t->r0);
        if ($t->r0) free($t->r0);
        $t->r0 = NULL;
        $t->len = 0;
        $t->cap = 0;
    }


acquires{A, B, C} destroy{ Sum{A, B, C} } (sum&)
    switch sum.builtinSumEnum
        0; sum.0 .destroy
        1; sum.1 .destroy
        2; sum.2 .destroy

    sum.builtinSumReset(0)
