module lexer 

import ../io
import ../chars



fn {s string} lexAlpha() (char, i64)
    let i = 0
    for s -> c | isSpace(c)
        i = i + 1
    if s[..][i] && isAlpha(s[i])
        return (s[i], i + 1)
    return ('\0', 0)


fn {s string} lexDigit() (char, i64)
    let i = 0
    for s -> c | isSpace(c)
        i = i + 1
    if s[..][i] && isDigit(s[i])
        return (s[i], i + 1)
    return ('\0', 0)


fn {s string, ident string} lexIdent() i64
    if s.lexAlpha() -> (c, i | i > 0)
        ident.push(c)
        let z = i
        for s[i..] -> j | s[j] -> c | isAlpha(c) || isDigit(c)
            ident.push(c)
            z = z + 1
        return z
    return 0


type StrKey i64
type Lexeme { LexNull() | LexIdent(StrKey) | LexInt(i64) }


fn {ss sparse[string]} lexIdent2(k StrKey) (Lexeme, i64)
    if ss[k].lexAlpha() -> (c, i) | i > 0
        let identKey = ss.push()
        ss[identKey].push(c)

        for ss[k][i..] -> j | ss[k][j] -> c | isAlpha(c) || isDigit(c)
            ss[identKey].push(c)

        return (LexIdent(identKey), i + ss[identKey].len() - 1)

    return (LexNull(), 0)


fn {io Io} main() 
    let file = {io, "main.doo"}.openFile()
    
    data line string
    while {io, line}.readLn(file)
        {io, line}.writeLn()
        line.clear()

    io.closeFile(file)

    data strings sparse[string]
    let key = strings.push()
    strings[key] = "  b134 43"

    switch strings.lexIdent2(key)
        (LexIdent(identKey), n); print(strings[identKey], n)
        (LexNull(), n)         ; print("null")

