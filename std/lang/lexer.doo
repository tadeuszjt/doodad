module lexer 

import ../io
import ../strings
import ../chars


type StrKey i64
type Lexeme { LexIdent(StrKey) | LexInt(i64) }
type LexResult (Lexeme, i64)

fn {s string} lexDigit(start i64) {char | null}
    for s[start..] -> i | isDigit(s[i]) 
        return conv(s[i])
    return null


fn {s string} lexAlpha(start i64) {char | null}
    for s[start..] -> i | isAlpha(s[i]) 
        return conv(s[i])
    return null


fn {s string} lexChar(start i64, c char) {char | null}
    for s[start..] -> i | s[i] == c
        return conv(s[i])
    return null


fn {s string} lexSpace(start i64) {char | null}
    for s[start..] -> i | isSpace(s[i])
        return conv(s[i])
    return null



fn {s string} lexSpaces(start i64) i64
    let count = 0
    for s[start..] -> i | s.lexSpace(i) -> char(_)
        count = count + 1
    return count


fn {ss sparse[string]} lexInt(start i64, key StrKey) {LexResult | null}
    let count = ss[key].lexSpaces(start)
    let n = 0

    while ss[key].lexDigit(start + count) -> char(c)
        n = n * 10
        n = n + i64(c - '0')
        count = count + 1

    if count == 0; return null
    else;          return conv( LexResult(LexInt(n), count) )
        

fn {ss sparse[string]} lexIdent(start i64, key StrKey) {LexResult | null}
    let count = ss[key].lexSpaces(start)

    if ss[key].lexAlpha(start + count) -> char(c)
        count = count + 1
        let id = ss.push()
        ss[id].push(c)

        while true 
            if      ss[key].lexAlpha(start + count) -> char(c); ss[id].push(c)
            else if ss[key].lexDigit(start + count) -> char(c); ss[id].push(c)
            else;   return conv( LexResult(LexIdent(id), count) )
            count = count + 1

    return null



fn {ss sparse[string]} lex(start i64, key StrKey) {LexResult | null}
    if ss.lexIdent(start, key) -> LexResult(a, b); return conv ( LexResult(a, b) )
    if ss.lexInt(start, key)   -> LexResult(a, b); return conv ( LexResult(a, b) )
    return null
    

fn {io Io, ss sparse[string]} writeLexeme(lexeme Lexeme)
    switch lexeme 
        LexInt(n)   ; io.write(n)
        LexIdent(id); {io, ss[id]}.write()


fn {io Io} main() 
    data ss sparse[string]

    let k = ss.push()
    ss[k] = "  asdjsad134  313"

    let start = 0
    while ss.lex(start, k) -> LexResult(lexeme, num)
        io.write(' ')
        {io, ss}.writeLexeme(lexeme)
        start = start + num

    io.write('\n')



