module lexer 

import ../io
import ../strings
import ../chars


type StrKey i64
type Lexeme { LexIdent(StrKey) | LexInt(i64) }
type LexResult (Lexeme, i64)

fn {s string} lexDigit(start i64) {char | null}
    for s[start..] -> i | isDigit(s[i]) 
        return conv(s[i])
    return null


fn {s string} lexAlpha(start i64) {char | null}
    for s[start..] -> i | isAlpha(s[i]) 
        return conv(s[i])
    return null


fn {s string} lexChar(start i64, c char) {char | null}
    for s[start..] -> i | s[i] == c
        return conv(s[i])
    return null


fn {s string} lexSpace(start i64) {char | null}
    for s[start..] -> i | isSpace(s[i])
        return conv(s[i])
    return null



fn {s string} lexSpaces(start i64) i64
    let count = 0
    for s[start..] -> i | s.lexSpace(i) -> char(_)
        count = count + 1
    return count


fn {ss sparse[string]} lexIdent(start i64, key StrKey) { LexResult | null }
    let count = ss[key].lexSpaces(start)

    if ss[key].lexAlpha(start + count) -> char(c)
        count = count + 1
        let id = ss.push()
        ss[id].push(c)

        while true 
            if ss[key].lexAlpha(start + count) -> char(c) 
                count = count + 1
                ss[id].push(c)
            else if ss[key].lexDigit(start + count) -> char(c)
                count = count + 1
                ss[id].push(c)
            else
                return conv( LexResult(LexIdent(id), count) )

    return null
    

fn {io Io} main() 
    data strings sparse[string]

    let k = strings.push()
    strings[k] = "  asd134"

    if strings.lexIdent(0, k) -> LexResult(lexeme, n)
        switch lexeme
            LexIdent(l); print(strings[l], n)

